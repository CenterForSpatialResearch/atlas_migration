<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>Map and Star Chart</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <link rel="stylesheet" href="main.css">
</head>

<body>
    <div id="tooltip" class="hidden">
        <p><span id="val"></span></p>
    </div>

    <div id="filter-container">
        <label for="city-select">Select City: </label>
        <select id="city-select">
            <option value="all">All</option>
            <option value="Johannesburg">Johannesburg</option>
            <option value="Nairobi">Nairobi</option>
            <option value="Accra">Accra</option>
        </select>

        <label for="neighborhood-select">Select Neighborhood: </label>
        <select id="neighborhood-select">
            <option value="all">All</option>
        </select>
        <button id="download-svg">Download SVG</button>
        <button id="download-legend">Download Legend</button>
        <button onclick="downloadLegendPNG()">Download Legend PNG</button>

    </div>
    <div id="map"></div>
    <div id="legend">
        <div id="left-legend-container"></div>
        <div id="chart-container"></div>
        <div id="chart-title">
            <div id="people-legend"></div>
            <div id="chart-title-container"></div>
            <div id="chart-subtext-container"></div>
        </div>
        <div id="right-legend-container"></div>
    </div>

    <!-- script -->
    <script type="text/javascript">
        // var width = innerWidth;
        // var height = 600;

        var mapContainer = document.getElementById('map');
        var width = mapContainer.offsetWidth;
        var height = mapContainer.offsetHeight;

        // var projection = d3.geoMercator()
        // var projection = d3.geoAzimuthalEqualArea() // for globe view
        var projection = d3.geoAzimuthalEquidistant() //for zoom in views
            .center([0, 20])
            .scale(150)
            .translate([width / 2, height / 2]);

        var path = d3.geoPath()
            .projection(projection);

        var svg = d3.select("#map").append("svg")
            .attr("width", width)
            .attr("height", height);

        var cityColor = "#f8961d";
        var townColor = "#e0c300";
        var villageColor = "#98b759";
        
        var colorReasons = {
            "Education": "#faa61a", // "#ff00f7"
            "Work": "#007dc5", // "#17becf"
            "Housing": "#f26522", // "#fcba03"
            "Restart": "#21409a", // "#79dc53"
            "Kin": "#ed1a3b", // "#5cbf75"
            "Remain": "#cf128c", // "#695DEF"
            "Safety": "#5fbb46" // "#E12991"
        };

        var cityCoordinates = {
            'Johannesburg': [28.0473, -26.2041],
            'Nairobi': [36.8219, -1.2921],
            'Accra': [-0.1870, 5.6037]
        };

        var validNairobiNeighborhoods = new Set(["Kawangware", "Kayole", "Ongata Rongai"]);

        var distanceMarkers = {
            "Nairobi": [
                { location: "Nairobi", dist: 2900, name: "Johannesburg, South Africa" },
                { location: "Nairobi", dist: 500, name: "Kampala, Uganda" },
                { location: "Nairobi", dist: 60, name: "Machakos, Kenya" }
            ],
            "Accra": [
                { location: "Accra", dist: 400, name: "Lagos, Nigeria" },
                { location: "Accra", dist: 4300, name: "Nairobi, Kenya" },
                { location: "Accra", dist: 160, name: "Lome, Togo" }
            ],
            "Johannesburg": [
                { location: "Johannesburg", dist: 3456, name: "Addis Ababa, Ethiopia" },
                { location: "Johannesburg", dist: 450, name: "Maputo, Mozambique" },
                { location: "Johannesburg", dist: 50, name: "Pretoria, South Africa" }
            ]
        };

        var polylines = []; // Array to store polylines
        var migrations = [];
        var neighborhoodsByCity = {}; // Object to store neighborhoods by city

        Promise.all([
            d3.json("data/ref/countries-10m.geo.json"), // High resolution
            d3.json("data/ref/world_countries.geo.json"), // Low resolution
            d3.json("data/ref/world-urban-polygons.geojson"),
            d3.json("data/ref/h2o-.geo.json"),
            d3.csv("data/star_all_distances.csv"),
            d3.csv("data/level1_migrations_UR_R.csv"),
            d3.csv("data/origin_migrations_UR.csv") // This data will have the data of num_move and the type of migration
        ]).then(function (data) {
            var highResWorld = data[0];
            var lowResWorld = data[1];
            var urbanPolygons = data[2];
            var waterBodies = data[3];
            var allpts = data[4];
            var migrations = data[5];
            var originMigrations = data[6]; // should not be used for locations...

            svg.append("g")
                .selectAll("path")
                .data(highResWorld.features)
                .enter().append("path")
                .attr("d", path)
                .attr("fill","#f0f0f0")
                .attr("stroke","#d1d1d1")
                .attr("stroke-width", .5);

            svg.append("g")
                .selectAll("path")
                .data(waterBodies.features)
                .enter()
                .append("path")
                .attr("d", path)
                .attr("fill","#ffffff")
                .attr("stroke","#ffffff")
                .attr("stroke-width", .25)

            svg.append("g")
                .attr("class","urban-layer")
                .selectAll("path")
                .data(urbanPolygons.features)
                .enter()
                .append("path")
                .attr("d", path)
                .attr("fill","#dedede")
                .attr("stroke","#dedede")
                .attr("stroke-width", .25);

            var graticule = d3.geoGraticule().step([1, 1]);
            var gridLines = svg.append("g").attr("class", "graticule");

            gridLines.append("path")
                .datum(graticule)
                .attr("class", "graticule")
                .attr("d", path)
                .attr("stroke", "#cccccc")
                .attr("stroke-width", .25)
                .attr("fill", "none");

            var locationToNeighborhood = createLocationToNeighborhoodMapping(allpts);
            populateNeighborhoodsByCity(migrations, locationToNeighborhood);
            ready(migrations, originMigrations, locationToNeighborhood);
        }).catch(function (error) {
            console.error('Error loading data:', error);
        });

        function createLocationToNeighborhoodMapping(data) {
            var mapping = {};
            data.forEach(function (d) {
                mapping[d.location] = d.neighborhood_9;
            });
            return mapping;
        }

        function populateNeighborhoodsByCity(migrations, locationToNeighborhood) {
            migrations.forEach(function (migration) {
                var city = migration.city_8;
                var location = migration.location;
                var neighborhood = locationToNeighborhood[location] || 'Unknown';

                if (city === 'Nairobi' && !validNairobiNeighborhoods.has(neighborhood)) {
                    return; // Skip neighborhoods not in the valid set for Nairobi
                }

                if (!neighborhoodsByCity[city]) {
                    neighborhoodsByCity[city] = new Set();
                }
                neighborhoodsByCity[city].add(neighborhood);
            });

            // console.log(neighborhoodsByCity); // Debugging log to check the neighborhoods by city
        }

        function updateNeighborhoodDropdown(city) {
            var neighborhoodSelect = document.getElementById('neighborhood-select');
            neighborhoodSelect.innerHTML = '<option value="all">All</option>'; // Capitalize "All"

            if (neighborhoodsByCity[city]) {
                neighborhoodsByCity[city].forEach(function (neighborhood) {
                    var option = document.createElement('option');
                    option.value = neighborhood;
                    option.text = neighborhood;
                    neighborhoodSelect.appendChild(option);
                });
            }
        }

        // Function to get color based on the out_thm value
        function getColorByOutThm(out_thm) {
            return colorReasons[out_thm] || null; // Default to black if not found
        }

        function ready(loadedMigrations, originMigrations, locationToNeighborhood) {
            migrations = loadedMigrations;
            // console.log(locationToNeighborhood); // Debugging log to check the location to neighborhood mapping

            // Draw lines from selected cities to each destination using migrations
            migrations.forEach(function (migration) {
                var city = migration.city_8;
                if (cityCoordinates[city]) {
                    var location = migration.location; // Get the location from migration data
                    var neighborhood = locationToNeighborhood[location] || 'Unknown';
                    if (city === 'Nairobi' && !validNairobiNeighborhoods.has(neighborhood)) {
                        return; // Skip neighborhoods not in the valid set for Nairobi
                    }

                    var out_thm = migration.out_thm; // Get the out_thm value from your data
                    var color = getColorByOutThm(out_thm);

                    var startPoint = projection(cityCoordinates[city]); // City coordinates
                    var endPoint = projection([+migration.lat, +migration.lon]); // Ensure the coordinates are numbers

                    var locationParts = location.replace(/[()']/g, '').split(', ');
                    var locationText = `${locationParts[0]}, ${locationParts[2]}`;

                    // console.log('Drawing line from', startPoint, 'to', endPoint, 'with weight', migration.num_moves, 'color', color); // Debugging log
                    // console.log('Path:', {
                    //     start: startPoint,
                    //     end: endPoint,
                    //     neighborhood: neighborhood,
                    //     location: location,
                    //     q100Value: locationToQ100[location]
                    // });

                    var line = svg.append("line")
                        .attr("x1", startPoint[0])
                        .attr("y1", startPoint[1])
                        .attr("x2", endPoint[0])
                        .attr("y2", endPoint[1])
                        .attr("stroke", color)
                        .attr("stroke-width", migration.num_moves*1.5)
                        .attr("opacity", 0.7)
                        // .datum({ city: city, neighborhood: neighborhood, lon: migration.lon, lat: migration.lat }); // Save coordinates for zoom
                        .datum({ city: city, neighborhood: neighborhood, lon: migration.lon, lat: migration.lat, location: locationText });

                    polylines.push(line); // Store the line

                }
            });

            // Initialize filters
            filterPolylines();
        }

        document.getElementById('city-select').addEventListener('change', function () {
            var selectedCity = this.value;
            updateNeighborhoodDropdown(selectedCity);
            filterPolylines();
            zoomToCity(selectedCity);
        });

        document.getElementById('neighborhood-select').addEventListener('change', function () {
            filterPolylines();
        });

        function filterPolylines() {
            var selectedCity = document.getElementById('city-select').value.toLowerCase();
            var selectedNeighborhood = document.getElementById('neighborhood-select').value.toLowerCase();

            svg.selectAll("line").remove(); // Remove all lines first
            svg.selectAll("text").remove(); // Remove all text labels first

            console.log('Filtered migrations before sorting:', migrations); // Debugging line

            if (migrations.length === 0) {
                console.warn('No migrations data available.');
                return;
            }

            var sortedMigrations = migrations.slice().sort(function(a, b) {
                return b.num_moves - a.num_moves;
            });

            var topMigrations = sortedMigrations.slice(0, 50)
            var bottomMigrations = sortedMigrations.slice(800,820)
            var combinedMigrations = topMigrations.concat(bottomMigrations);

            var locationNames = new Set(combinedMigrations.map(function(m) { 
                // Parse the location string
                var locationParts = m.location.replace(/[()']/g, '').split(', ');

                // Check if locationParts[0] is 'nan' and skip it
                if (locationParts.length > 2 && locationParts[0].toLowerCase() !== 'nan') {
                    return `${locationParts[0]}, ${locationParts[2]}`;
                } else {
                    return null;
                }
                }).filter(function(location) {
                    return location !== null && location !== '';
            }));

            console.log('Top migrations:', topMigrations); // Debugging line
            console.log('Origin locations:', locationNames); // Debugging line

            polylines.forEach(function (line) {
                var cityMatches = selectedCity === 'all' || line.datum().city.toLowerCase() === selectedCity;
                var neighborhoodMatches = selectedNeighborhood === 'all' || line.datum().neighborhood.toLowerCase() === selectedNeighborhood;
                if (cityMatches && neighborhoodMatches) {
                    var startPoint = projection(cityCoordinates[line.datum().city]); // City coordinates
                    var endPoint = projection([+line.datum().lat, +line.datum().lon]); // Ensure the coordinates are numbers

                    svg.append("line")
                        .attr("x1", startPoint[0])
                        .attr("y1", startPoint[1])
                        .attr("x2", endPoint[0])
                        .attr("y2", endPoint[1])
                        .attr("stroke", line.attr("stroke"))
                        .attr("stroke-width", line.attr("stroke-width"))
                        .attr("opacity", line.attr("opacity"));

                        if (locationNames.has(line.datum().location)) {
                        svg.append("text")
                            .attr("x", endPoint[0])
                            .attr("y", endPoint[1])
                            .attr("class","origin-text")
                            .attr("dy", ".35em")
                            .text(line.datum().location);
                    }
                }
            });

            // console.log("Filtered for city: " + selectedCity + " and neighborhood: " + selectedNeighborhood);
        }

        var cityZoomLevels = {
                'Johannesburg': { scale: 1500, center: [28.0473, -20] },// city center [28.0473, -26.2041]
                'Nairobi': { scale: 2500, center: [30.8219, 1] }, // city center [36.8219, -1.2921]
                'Accra': { scale: 4000, center: [-0.1870, 10] }, // city center [-0.1870, 5.6037]
                'all': { scale: 450, center: [0, 10] } // Default zoom level and center
            };

        function zoomToCity(city) {
            var zoomConfig = cityZoomLevels[city] || cityZoomLevels['all'];

            projection
                .center(zoomConfig.center)
                .scale(zoomConfig.scale);

            svg.selectAll("path")
                .attr("d", path); // Redraw paths

            svg.selectAll("line").remove(); // Remove all lines
            svg.selectAll("text").remove(); // Remove all text labels

            filterPolylines(); // Re-draw polylines at new zoom level
        }



        var zoom = d3.zoom()
            .scaleExtent([1, 8])
            .on("zoom", zoomed);

        svg.call(zoom);

        function zoomed(event) {
            var { transform } = event;

            svg.selectAll("path")
                .attr("transform", transform);

            svg.selectAll("line")
                .attr("transform", transform);

            svg.selectAll("text")
                .attr("transform", transform);
        }

var chartWidth = 300;
var chartHeight = 300;
var padding = 10;

var rowConverter = function (d) {
    return {
        resp_id: d.ID,
        city: d.location_l,
        nearcity: d.location_near,
        country_location: d.location_country,
        country_orig: d.orig_country_103,
        num_moves: d.number_moves_200,
        cumulative_dist: parseFloat(d.dist),
        current_city: d.city_8,
        neighborhood: d.neighborhood_9,
        ur_acms: d.Q100_1_URACMS,
        outR: d.out_thm
    };
};

var radialScale = d3.scaleLog()
    .domain([.002, 10000])
    .range([0, chartWidth / 2 - padding]);

var ticks_set = [.01, 10, 100, 1000, 10000];

function angleToCoordinate(angle, value) {
    var x = Math.cos(angle) * radialScale(value);
    var y = Math.sin(angle) * radialScale(value);
    return { "x": x, "y": y }; // Remove offset to center in the group
}

function polarCoords(value, index, list) {
    var angle = Math.PI + ((index * 2 * Math.PI) / (list.length)); // Original angle calculation
    var rotatedAngle = angle + Math.PI; // Rotate by an additional 90 degrees (Ï€/2 radians)
    return angleToCoordinate(rotatedAngle, value); // Use the rotated angle
}

var chartContainer = d3.select("#chart-container");
var legendContainer = d3.select("#legend-container");

function updateChart(selectedCity, selectedNeighborhood) {
    chartContainer.selectAll("*").remove();
    legendContainer.selectAll("*").remove();
    d3.select("#chart-title-container").selectAll("*").remove(); // Clear existing title container
    d3.select("#chart-subtext-container").selectAll("*").remove(); // Clear existing subtext container

    var filteredData = dataset.filter(d => (selectedCity === "all" || d.current_city.toLowerCase() === selectedCity) &&
        (selectedNeighborhood === "all" || d.neighborhood.toLowerCase() === selectedNeighborhood));

    // Filter out data points with NaN cumulative_dist
    filteredData = filteredData.filter(d => !isNaN(d.cumulative_dist));

    // Sort data first by outR (category/color) and then by cumulative_dist
    filteredData.sort((a, b) => {
        if (a.outR < b.outR) return -1;
        if (a.outR > b.outR) return 1;
        return b.cumulative_dist - a.cumulative_dist;
    });

// Group by neighborhood and sort within each neighborhood to get top 5 by num_moves
var neighborhoods = d3.group(filteredData, d => d.neighborhood);
    neighborhoods.forEach((places, neighborhood) => {
        var top5 = places.sort((a, b) => b.num_moves - a.num_moves).slice(0, 5); // Sort by num_moves
        // console.log(`\nTop 5 places in "${neighborhood}" by number of moves:`);
        top5.forEach((place, index) => {
            const type = place.ur_acms === 'City' ? 'City' : place.ur_acms === 'Town' ? 'Town' : 'Village';
            // console.log(`${index + 1}. Respondent ID: ${place.resp_id}, Number of Moves: ${place.num_moves}, Type: ${type}, Location: ${place.city}, ${place.country_orig}`);
        });
    });;

    var svg = chartContainer.append("svg")
        .attr("width", 400)
        .attr("height", 400);

    var circle_group = svg.append("g")
        .attr("class", "chart")
        .attr("transform", "translate(" + chartWidth / 2 + "," + chartHeight / 2 + ")"); // Center the group

    var lines = circle_group.append("g")
        .attr("class", "lines");

    lines.selectAll("line")
        .data(filteredData)
        .enter()
        .append("line")
        .attr("x1", 0)
        .attr("x2", (d, i, n) => polarCoords(d.cumulative_dist, i, n).x)
        .attr("y1", 0)
        .attr("y2", function (d, i, n) {
            var coordinate = polarCoords(d.cumulative_dist, i, n).y;
            return coordinate;
        })
        .attr("stroke", d => getColorByOutThm(d.outR))  // Use outR (which is out_thm) for color
        .attr("stroke-width", .5)
        .on("mouseover", function (event, d) {
            d3.select("#tooltip")
                .select("#val")
                .text(d.out_thm + " dist: " + d.cumulative_dist + " Respondent " + d.resp_id + " is from " + d.city + ", " + d.country_orig + " which is " + d.cumulative_dist + " kilometers away from " + d.current_city);
            d3.select("#tooltip").classed("hidden", false);
        })
        .on("mouseout", function () {
            d3.select("#tooltip").classed("hidden", true);
        });

    var scale = circle_group.append("g")
        .attr("class", "scale");
    scale.selectAll("circle")
        .data(ticks_set)
        .enter()
        .append("circle")
        .attr("class", "scale")
        .attr("id", (d, i) => "fixed-dist" + i)
        .attr("cx", 0)
        .attr("cy", 0)
        .attr("fill", "none")
        .attr("r", d => radialScale(d))
        .attr("stroke-width", .25);

    scale.selectAll("text")
        .data(ticks_set)
        .enter()
        .append("text")
        .attr("x", 0)
        .attr("y", d => -radialScale(d))
        .text(d => d + " km")
        .attr("class", "scale-path")
        .attr("text-anchor", "middle"); // Center the text

    var scale_relative = circle_group.append("g")
        .attr("class", "scale_rel");

    var dist_markers = distanceMarkers[selectedCity.charAt(0).toUpperCase() + selectedCity.slice(1)] || [];

    scale_relative.selectAll("circle")
        .data(dist_markers)
        .enter()
        .append("circle")
        .attr("class", "scale-dashed")
        .attr("id", (d, i) => "cities-dist" + d.dist)
        .attr("cx", 0)
        .attr("cy", 0)
        .attr("fill", "none")
        .attr("r", function (d) {
            return radialScale(d.dist);
        })
        .attr("stroke-width", .5);

    scale_relative.selectAll("text")
        .data(dist_markers)
        .enter()
        .append("text")
        .attr("x", d => -radialScale(d.dist))
        .attr("y", d => chartHeight / 2 - radialScale(d.dist))
        .text(d => d.name + ", " + d.dist + " km")
        .attr("class", "scale-path")
        .attr("text-anchor", "left");

    // Update legends
    updateRightLegend(filteredData);

    // Update chart title and subtitle based on the selected city
    let cityName, countryName;
    if (selectedCity === 'nairobi') {
        cityName = "Nairobi";
        countryName = "Kenya";
    } else if (selectedCity === 'accra') {
        cityName = "Accra";
        countryName = "Ghana";
    } else if (selectedCity === 'johannesburg') {
        cityName = "Johannesburg";
        countryName = "South Africa";
    } else {
        cityName = "City";
        countryName = "Country";
    }

    if (selectedCity !== 'all') {
        d3.select("#chart-title-container").append("div")
            .attr("class", "chart-title")
            .text(`Compiled reasons to leave most recent city of residence`);

        d3.select("#chart-subtext-container").append("div")
            .attr("class", "chart-subtext")
            .text(`For respondents currently living in ${cityName}, ${countryName} using the 200's group of survey columns`);
    }
}


function updateRightLegend(filteredData) {
    var rightLegendContainer = d3.select("#left-legend-container");
    rightLegendContainer.selectAll("*").remove();

    var totalResponses = filteredData.length;
    var categoryCounts = d3.rollup(filteredData, v => v.length, d => d.outR);

    // Prepare legend data with colors, percentages, and counts
    var legendData = Object.keys(colorReasons).map(category => {
        var count = categoryCounts.get(category) || 0;
        var percentage = ((count / totalResponses) * 100).toFixed(1);
        return {
            category: category,
            color: colorReasons[category],
            percentage: percentage + "%",
            count: count
        };
    });

    // Sort legend data by percentage descending
    legendData.sort((a, b) => b.count - a.count);

    // Calculate Responses and Non-Responses
    var responses = legendData.reduce((sum, item) => sum + item.count, 0);
    var nonResponses = totalResponses - responses;
    var responsePercentage = ((responses / totalResponses) * 100).toFixed(1);
    var nonResponsePercentage = ((nonResponses / totalResponses) * 100).toFixed(1);

    // Add title and subtitle
    rightLegendContainer.append("div")
        .attr("class", "legend-title")
        .style("font-weight", "bold")
        .style("margin-bottom", "8px")
        .text("% of most recent migrations");

    rightLegendContainer.append("div")
        .attr("class", "legend-subtitle")
        .style("font-weight", "bold")
        .style("margin-bottom", "8px")
        .style("font-size", "16px")
        .text("Push Factor Themes");

    // Add the legend items
    legendData.forEach(item => {
        var legendItem = rightLegendContainer.append("div")
            .attr("class", "legend-item")
            .style("display", "flex")
            .style("align-items", "center")
            .style("margin-bottom", "4px");

        legendItem.append("div")
            .attr("class", "legend-color")
            .style("background-color", item.color)
            .style("width", "18px")
            .style("height", "18px")
            .style("margin-right", "8px");

        var textContainer = legendItem.append("div")
            .attr("class", "legend-text")
            .style("flex-grow", "1");

        textContainer.append("div")
            .attr("class", "legend-category")
            .style("font-weight", "bold")
            .text(`${item.category}`);

        textContainer.append("div")
            .attr("class", "legend-percentage")
            .style("margin-left", "auto")
            .text(` ${item.percentage}`);
    });

    // Add a divider line
    rightLegendContainer.append("hr")
        .style("border", "none")
        .style("border-top", "1px solid #ccc")
        .style("margin", "8px 0");

    // Add Responses and Non-Responses
    var responsesItem = rightLegendContainer.append("div")
        .attr("class", "legend-item")
        .style("display", "flex")
        .style("align-items", "center")
        .style("margin-bottom", "4px");

    responsesItem.append("div")
        .attr("class", "legend-color")
        .style("background-color", "#ffffff") // Adjust color as needed
        .style("width", "18px")
        .style("height", "18px")
        .style("margin-right", "8px");

    responsesItem.append("div")
        .attr("class", "legend-text")
        .style("flex-grow", "1")
        .text("Responses");

    responsesItem.append("div")
        .attr("class", "legend-percentage")
        .style("margin-left", "auto")
        .text(`${responsePercentage}%`);

    var nonResponsesItem = rightLegendContainer.append("div")
        .attr("class", "legend-item")
        .style("display", "flex")
        .style("align-items", "center");

    nonResponsesItem.append("div")
        .attr("class", "legend-color")
        .style("background-color", "#f0f0f0") // Light grey for Non-Responses
        .style("width", "18px")
        .style("height", "18px")
        .style("margin-right", "8px");

    nonResponsesItem.append("div")
        .attr("class", "legend-text")
        .style("flex-grow", "1")
        .text("Non-Responses");

    nonResponsesItem.append("div")
        .attr("class", "legend-percentage")
        .style("margin-left", "auto")
        .text(`${nonResponsePercentage}%`);
}


        function capitalizeFirstLetter(string) {
            return string.charAt(0).toUpperCase() + string.slice(1);
        }

    var legendDiv = d3.select("#people-legend");
        var svgWidth = 300;  // Set the initial desired width
        var svgHeight = 50; // Set the desired height
        var strokeThicknesses = [1, 2, 3, 4, 3]; // Line thicknesses
        var labels = [1, 3, 5, 7, 10]; // Labels to display below the lines

        var initialLineLength = svgWidth; // Starting length for the first line

        // Create the SVG element inside the div
                var peopleLegend = legendDiv.append("svg")
                    .attr("width", svgWidth)
                    .attr("height", svgHeight);

        var cumulativeY = 0;
        strokeThicknesses.forEach(function(thickness, index) {
            var currentLineLength = initialLineLength - (index * 50); // Decrease line length for each line

            if (currentLineLength < 0) {
                currentLineLength = 0; // Ensure the line length doesn't become negative
            }

            peopleLegend.append("line")
                .attr("x1", svgWidth) // Start from the right side
                .attr("x2", svgWidth - currentLineLength) // Draw to the left
                .attr("y1", cumulativeY)
                .attr("y2", cumulativeY)
                .attr("stroke", "black")
                .attr("stroke-width", thickness*2);

            // Add text label below the line
            peopleLegend.append("text")
                .attr("x", svgWidth - currentLineLength )
                .attr("y", 30)
                .attr("class", "legend-subtext") 
                .text(labels[index]); // Set the text to the corresponding label

            cumulativeY += thickness; // Increase the cumulative y-coordinate by the thickness of the current line

            peopleLegend.append("text")
            .attr("x", svgWidth-40) 
            .attr("y", 30)
            .attr("class", "legend-subtext") 
            .text('people')

        });

        var dataset;

        d3.csv("data/star_recent_R_UseThis_3.csv", rowConverter).then(function (data) {
            dataset = data;

            var cities = Array.from(new Set(data.map(d => d.current_city)));
            cities.unshift("All"); // Capitalize "All"
            var citySelect = d3.select("#city-select");

            citySelect.selectAll("option")
                .data(cities)
                .enter()
                .append("option")
                .text(d => d)
                .attr("value", d => d.toLowerCase());

            citySelect.on("change", function () {
                var selectedCity = d3.select(this).property("value").toLowerCase();

                var neighborhoods = Array.from(new Set(dataset.filter(d => selectedCity === "all" || d.current_city.toLowerCase() === selectedCity).map(d => d.neighborhood)));
                neighborhoods = neighborhoods.filter(n => n !== '-3'); // Exclude "-3" neighborhood
                neighborhoods.unshift("All"); // Capitalize "All"
                var neighborhoodSelect = d3.select("#neighborhood-select");

                neighborhoodSelect.selectAll("option").remove();
                neighborhoodSelect.selectAll("option")
                    .data(neighborhoods)
                    .enter()
                    .append("option")
                    .text(d => d)
                    .attr("value", d => d.toLowerCase());

                neighborhoodSelect.on("change", function () {
                    var selectedNeighborhood = d3.select(this).property("value").toLowerCase();
                    updateChart(selectedCity, selectedNeighborhood);
                    filterPolylines(); // Update the map when the neighborhood is changed
                });

                // Update chart for the first neighborhood
                neighborhoodSelect.property("value", "all").dispatch("change");
            });

            // Initial chart rendering for "all" city and "all" neighborhood
            citySelect.property("value", "all").dispatch("change");
        }).catch(function (error) {
            console.error('Error loading or parsing data:', error);
        });

        function createLegend() {
            var legend = d3.select("#legend-reason");

            legend.append("div")
                .attr("class", "legend-title")
                .text("Reasons for Migration");

            Object.keys(colorReasons).forEach(function (key) {
                var legendItem = legend.append("div")
                    .attr("class", "legend-item");

                legendItem.append("div")
                    .attr("class", "legend-color")
                    .style("background-color", colorReasons[key]);

                legendItem.append("div")
                    .attr("class", "legend-text")
                    .text(key);
            });
        }

        function downloadSVG() {
            var svgElement = document.querySelector("#map svg"); // Select the SVG element

            // Create a blob from the SVG XML
            var svgBlob = new Blob([svgElement.outerHTML], { type: "image/svg+xml;charset=utf-8" });
            var svgUrl = URL.createObjectURL(svgBlob);
            var downloadLink = document.createElement("a");
            downloadLink.href = svgUrl;
            downloadLink.download = "visualization.svg";

            // Trigger the download
            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);
        }

        function downloadLegendPNG() {
            var legendElement = document.querySelector("#legend");
            
            html2canvas(legendElement).then(canvas => {
                var imgData = canvas.toDataURL('image/png');
                var downloadLink = document.createElement("a");
                downloadLink.href = imgData;
                downloadLink.download = "legend.png";

                // Trigger the download
                document.body.appendChild(downloadLink);
                downloadLink.click();
                document.body.removeChild(downloadLink);
            });
        }

        function downloadLegend() {
            var legendElement = document.querySelector("#legend");
            var svgWidth = legendElement.offsetWidth;
            var svgHeight = legendElement.offsetHeight;

            var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            svg.setAttribute("width", svgWidth);
            svg.setAttribute("height", svgHeight);
            svg.setAttribute("xmlns", "http://www.w3.org/2000/svg");

            appendDivAsSvgElement(svg, document.querySelector("#left-legend-container"), 0, 0);
            appendDivAsSvgElement(svg, document.querySelector("#right-legend-container"), 300, 0);
            appendDivAsSvgElement(svg, document.querySelector("#chart-container"), 600, 0);
            appendDivAsSvgElement(svg, document.querySelector("#chart-title-container"), 600, 200);
            appendDivAsSvgElement(svg, document.querySelector("#chart-subtext-container"), 600, 250);

            var serializer = new XMLSerializer();
            var svgBlob = new Blob([serializer.serializeToString(svg)], { type: "image/svg+xml;charset=utf-8" });
            var svgUrl = URL.createObjectURL(svgBlob);
            var downloadLink = document.createElement("a");
            downloadLink.href = svgUrl;
            downloadLink.download = "legend.svg";

            // Trigger the download
            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);
        }

        function appendDivAsSvgElement(svg, divElement, offsetX, offsetY) {
            var foreignObject = document.createElementNS("http://www.w3.org/2000/svg", "foreignObject");
            foreignObject.setAttribute("width", divElement.offsetWidth);
            foreignObject.setAttribute("height", divElement.offsetHeight);
            foreignObject.setAttribute("x", offsetX);
            foreignObject.setAttribute("y", offsetY);

            var div = document.createElement("div");
            div.setAttribute("xmlns", "http://www.w3.org/1999/xhtml");
            div.style.width = divElement.offsetWidth + "px";
            div.style.height = divElement.offsetHeight + "px";

            var clonedDiv = divElement.cloneNode(true);
            inlineAllStyles(clonedDiv);
            div.appendChild(clonedDiv);

            foreignObject.appendChild(div);
            svg.appendChild(foreignObject);
        }

        function inlineAllStyles(element) {
            var allElements = element.querySelectorAll("*");
            allElements.forEach(function(el) {
                var computedStyle = getComputedStyle(el);
                var styleString = "";
                for (var key of computedStyle) {
                    if (computedStyle.getPropertyValue(key)) {
                        styleString += key + ":" + computedStyle.getPropertyValue(key) + ";";
                    }
                }
                el.setAttribute("style", styleString);
            });
        }

        document.getElementById("download-svg").addEventListener("click", downloadSVG);
        document.getElementById("download-legend").addEventListener("click", downloadLegend);
    </script>
</body>
</html>