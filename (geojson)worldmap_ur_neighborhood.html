<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>Map and Star Chart</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <style type="text/css">
        body {
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
        }

        .title {
            font-family: "StanhopeRR Bold";
            font-size: 18px;
        }

        #tooltip {
            position: fixed;
            right: 20px;
            width: 200px;
            height: auto;
            padding: 10px;
            background-color: #ffffff;
            outline: black solid 1px;
        }

        #tooltip.hidden {
            display: none;
        }

        #tooltip p {
            margin: 0px;
            font-size: 16px;
            line-height: 20px;
        }

        .scale-path {
            font-size: 11px;
            fill: #969696;
        }

        .legend-text {
            font-size: 14px;
            fill: #969696;
        }

        .legend-number {
            font-size: 18px;
            font-weight: bold;
            fill: black;
        }

        .legend-label {
            font-size: 14px;
            font-weight: normal;
            fill: black;
        }

        .legend-category {
            font-size: 14px;
            font-weight: normal;
            fill: black;
        }

        .scale {
            stroke: #969696;
            stroke-width: 0.25px;
        }

        .scale-dashed {
            stroke: #969696;
            stroke-width: 0.25px;
            stroke-dasharray: 3, 3;
        }

        #chart-container {
            margin-right: 20px;
        }

        #right-legend-container {
            width: 200px;
            margin-left: 20px;
        }

        #left-legend-container {
            width: 300px;
            margin-left: 20px;
        }

        #map {
            height: 600px;
            width: 100vw;
        }

        #filter {
            top: 10px;
            left: 10px;
            background: white;
            padding: 10px;
            border: 1px solid #ccc;
        }

        #legend {
            display: flex;
            flex-direction: row;
        }

        .legend-container {
            display: flex;
            flex-direction: column;
            font-family: 'StanhopeRR Bold', sans-serif;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }

        .legend-color {
            width: 18px;
            height: 18px;
            margin-right: 8px;
        }

        .legend-text {
            font-size: 14px;
            line-height: 18px;
        }

        .legend-title {
            font-size: 18px;
            margin-bottom: 10px;
        }

        .legend-subtext {
            font-size: 12px;
            color: #555;
        }

        .legend-subtext-2 {
            font-size: 12px;
            width: 72px;
            text-align: end;
            color: #555;
        }

        .legend-highlight {
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 5px;
        }

        .legend-category {
            font-size: 14px;
            font-weight: normal;
            fill: black;
        }

        .legend-percentage {
            font-size: 14px;
        }

        .legend-header {
            font-size: 14px;
            font-weight: bold;
        }

        .legend-counts {
            font-size: 14px;
        }

        .legend-svg-container {
            display: flex;
            align-items: center;
        }

        #chart-title {
            width: 200px;
            margin-top: 20px;
        }

        #chart-title-container {
            width: 200px;
            margin-top: 20px;
        }

        .chart-title {
            font-size: 18px;
            font-weight: bold;
        }

        #chart-subtext-container {
            margin-top: 10px;
        }

        .chart-subtext {
            font-size: 14px;
            color: #555;
        }

        .legend-header-container {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            margin-bottom: 10px;
        }

        .legend-title-container {
            margin-bottom: 20px;
        }

        .legend-combined-container {
            display: flex;
            flex-direction: row;
            gap: 20px;
        }

        .legend-detail-container {
            display: flex;
            flex-direction: row;
            gap: 20px;
            margin-bottom: 5px;
        }
    </style>
</head>

<body>
    <div id="tooltip" class="hidden">
        <p><span id="val"></span></p>
    </div>

    <div id="filter-container">
        <label for="city-select">Select City: </label>
        <select id="city-select">
            <option value="all">All</option>
            <option value="Johannesburg">Johannesburg</option>
            <option value="Nairobi">Nairobi</option>
            <option value="Accra">Accra</option>
        </select>

        <label for="neighborhood-select">Select Neighborhood: </label>
        <select id="neighborhood-select">
            <option value="all">All</option>
        </select>
        <button id="download-svg">Download SVG</button>
        <button id="download-legend">Download Legend</button>
        <button onclick="downloadLegendPNG()">Download Legend PNG</button>

    </div>
    <div id="map"></div>
    <div id="legend">
        <div id="left-legend-container"></div>
        <div id="right-legend-container"></div>
        <div id="chart-container"></div>
        <div id="chart-title">
            <div id="chart-title-container"></div>
            <div id="chart-subtext-container"></div>
        </div>
    </div>

    <!-- script -->
    <script type="text/javascript">
        var width = innerWidth;
        var height = 600;

        var projection = d3.geoMercator()
            .center([0, 20])
            .scale(150)
            .translate([width / 2, height / 2]);

        var path = d3.geoPath()
            .projection(projection);

        var svg = d3.select("#map").append("svg")
            .attr("width", width)
            .attr("height", height);

        var cityColor = "#f8961d";
        var townColor = "#e0c300";
        var villageColor = "#98b759";

        var cityCoordinates = {
            'Johannesburg': [28.0473, -26.2041],
            'Nairobi': [36.8219, -1.2921],
            'Accra': [-0.1870, 5.6037]
        };

        var validNairobiNeighborhoods = new Set(["Kawangware", "Kayole", "Ongata Rongai"]);

        var distanceMarkers = {
            "Nairobi": [
                { location: "Nairobi", dist: 2900, name: "Johannesburg, South Africa" },
                { location: "Nairobi", dist: 500, name: "Kampala, Uganda" },
                { location: "Nairobi", dist: 60, name: "Machakos, Kenya" }
            ],
            "Accra": [
                { location: "Accra", dist: 400, name: "Lagos, Nigeria" },
                { location: "Accra", dist: 4300, name: "Nairobi, Kenya" },
                { location: "Accra", dist: 160, name: "Lome, Togo" }
            ],
            "Johannesburg": [
                { location: "Johannesburg", dist: 3456, name: "Addis Ababa, Ethiopia" },
                { location: "Johannesburg", dist: 450, name: "Maputo, Mozambique" },
                { location: "Johannesburg", dist: 50, name: "Pretoria, South Africa" }
            ]
        };

        var polylines = []; // Array to store polylines
        var neighborhoodsByCity = {}; // Object to store neighborhoods by city

        Promise.all([
            d3.json("data/ref/countries-10m.geo.json"), // High resolution
            d3.json("data/ref/world_countries.geo.json"), // Low resolution
            d3.json("data/ref/world-urban-polygons.geojson"),
            d3.json("data/ref/h2o-.geo.json"),
            d3.csv("data/star_all_distances.csv"),
            d3.csv("data/level1_migrations_UR.csv"),
            d3.csv("data/origin_migrations_UR.csv") // This data will have the data of num_move and the type of migration
        ]).then(function (data) {
            var highResWorld = data[0];
            var lowResWorld = data[1];
            var urbanPolygons = data[2];
            var waterBodies = data[3];
            var allpts = data[4];
            var migrations = data[5];
            var originMigrations = data[6];

            svg.append("g")
                .selectAll("path")
                .data(highResWorld.features)
                .enter().append("path")
                .attr("d", path)
                .attr("fill", "#ccc")
                .attr("stroke", "#fff");

            var locationToNeighborhood = createLocationToNeighborhoodMapping(allpts);
            populateNeighborhoodsByCity(migrations, locationToNeighborhood);
            ready(migrations, originMigrations, locationToNeighborhood);
        }).catch(function (error) {
            console.error('Error loading data:', error);
        });

        function createLocationToNeighborhoodMapping(data) {
            var mapping = {};
            data.forEach(function (d) {
                mapping[d.location] = d.neighborhood_9;
            });
            return mapping;
        }

        function populateNeighborhoodsByCity(migrations, locationToNeighborhood) {
            migrations.forEach(function (migration) {
                var city = migration.city_8;
                var location = migration.location;
                var neighborhood = locationToNeighborhood[location] || 'Unknown';

                if (city === 'Nairobi' && !validNairobiNeighborhoods.has(neighborhood)) {
                    return; // Skip neighborhoods not in the valid set for Nairobi
                }

                if (!neighborhoodsByCity[city]) {
                    neighborhoodsByCity[city] = new Set();
                }
                neighborhoodsByCity[city].add(neighborhood);
            });

            console.log(neighborhoodsByCity); // Debugging log to check the neighborhoods by city
        }

        function updateNeighborhoodDropdown(city) {
            var neighborhoodSelect = document.getElementById('neighborhood-select');
            neighborhoodSelect.innerHTML = '<option value="all">All</option>'; // Capitalize "All"

            if (neighborhoodsByCity[city]) {
                neighborhoodsByCity[city].forEach(function (neighborhood) {
                    var option = document.createElement('option');
                    option.value = neighborhood;
                    option.text = neighborhood;
                    neighborhoodSelect.appendChild(option);
                });
            }
        }

        function getColorByQ100(value) {
            if (value === 'City') return cityColor;
            if (value === 'Town') return townColor;
            if (value === 'Village') return villageColor;
            return null; // Return null if no match
        }

        function ready(migrations, originMigrations, locationToNeighborhood) {
            console.log(locationToNeighborhood); // Debugging log to check the location to neighborhood mapping

            // Create a mapping for the Q100_1_URACMS column
            var locationToQ100 = {};
            originMigrations.forEach(function (d) {
                locationToQ100[d.location] = d.Q100_1_URACMS;
            });

            // Draw lines from selected cities to each destination using migrations
            migrations.forEach(function (migration) {
                var city = migration.city_8;
                if (cityCoordinates[city]) {
                    var location = migration.location; // Get the location from migration data
                    var neighborhood = locationToNeighborhood[location] || 'Unknown';
                    if (city === 'Nairobi' && !validNairobiNeighborhoods.has(neighborhood)) {
                        return; // Skip neighborhoods not in the valid set for Nairobi
                    }

                    var q100Value = locationToQ100[location];
                    var color = getColorByQ100(q100Value);

                    var startPoint = projection(cityCoordinates[city]); // City coordinates
                    var endPoint = projection([+migration.lat, +migration.lon]); // Ensure the coordinates are numbers

                    console.log('Drawing line from', startPoint, 'to', endPoint, 'with weight', migration.num_moves, 'color', color); // Debugging log
                    console.log('Path:', {
                        start: startPoint,
                        end: endPoint,
                        neighborhood: neighborhood,
                        location: location,
                        q100Value: q100Value
                    });

                    var line = svg.append("line")
                        .attr("x1", startPoint[0])
                        .attr("y1", startPoint[1])
                        .attr("x2", endPoint[0])
                        .attr("y2", endPoint[1])
                        .attr("stroke", color)
                        .attr("stroke-width", migration.num_moves)
                        .attr("opacity", 0.7)
                        .datum({ city: city, neighborhood: neighborhood, lon: migration.lon, lat: migration.lat }); // Save coordinates for zoom

                    polylines.push(line); // Store the line

                    // Add destination name text label
                    svg.append("text")
                        .attr("x", endPoint[0])
                        .attr("y", endPoint[1])
                        .attr("dy", ".35em")
                        .attr("text-anchor", "middle")
                        .style("font-size", "10px")
                        .text(location);
                }
            });

            // Initialize filters
            filterPolylines();
        }

        document.getElementById('city-select').addEventListener('change', function () {
            var selectedCity = this.value;
            updateNeighborhoodDropdown(selectedCity);
            filterPolylines();
            zoomToCity(selectedCity);
        });

        document.getElementById('neighborhood-select').addEventListener('change', function () {
            filterPolylines();
        });

        function filterPolylines() {
            var selectedCity = document.getElementById('city-select').value.toLowerCase();
            var selectedNeighborhood = document.getElementById('neighborhood-select').value.toLowerCase();

            svg.selectAll("line").remove(); // Remove all lines first
            svg.selectAll("text").remove(); // Remove all text labels first

            polylines.forEach(function (line) {
                var cityMatches = selectedCity === 'all' || line.datum().city.toLowerCase() === selectedCity;
                var neighborhoodMatches = selectedNeighborhood === 'all' || line.datum().neighborhood.toLowerCase() === selectedNeighborhood;
                if (cityMatches && neighborhoodMatches) {
                    var startPoint = projection(cityCoordinates[line.datum().city]); // City coordinates
                    var endPoint = projection([+line.datum().lat, +line.datum().lon]); // Ensure the coordinates are numbers

                    svg.append("line")
                        .attr("x1", startPoint[0])
                        .attr("y1", startPoint[1])
                        .attr("x2", endPoint[0])
                        .attr("y2", endPoint[1])
                        .attr("stroke", line.attr("stroke"))
                        .attr("stroke-width", line.attr("stroke-width"))
                        .attr("opacity", line.attr("opacity"));

                    // Add destination name text label
                    svg.append("text")
                        .attr("x", endPoint[0])
                        .attr("y", endPoint[1])
                        .attr("dy", ".35em")
                        .attr("text-anchor", "middle")
                        .style("font-size", "10px")
                        .text(line.datum().location);
                }
            });

            console.log("Filtered for city: " + selectedCity + " and neighborhood: " + selectedNeighborhood);
        }

        function zoomToCity(city) {
            var zoomLevel = 2; // Default zoom level for 'all'
            var center = [0, 20]; // Default center for 'all'

            if (city !== 'all' && cityCoordinates[city]) {
                zoomLevel = 6; // Adjust zoom level as needed
                center = cityCoordinates[city];
            }

            projection
                .center(center)
                .scale(150 * zoomLevel); // Adjust scale for zoom

            svg.selectAll("path")
                .attr("d", path); // Redraw paths
        }

        var zoom = d3.zoom()
            .scaleExtent([1, 8])
            .on("zoom", zoomed);

        svg.call(zoom);

        function zoomed(event) {
            var { transform } = event;

            svg.selectAll("path")
                .attr("transform", transform);

            svg.selectAll("line")
                .attr("transform", transform);

            svg.selectAll("text")
                .attr("transform", transform);
        }

        var chartWidth = 300;
        var chartHeight = 300;
        var padding = 10;

        var categoryColors = {
            "City": cityColor,
            "Town": townColor,
            "Village": villageColor
        };

        var rowConverter = function (d) {
            return {
                resp_id: d.ID,
                city: d.location_l,
                nearcity: d.location_near,
                country_location: d.location_country,
                country_orig: d.orig_country_103,
                num_moves: d.number_moves_200,
                cumulative_dist: parseFloat(d.dist),
                current_city: d.city_8,
                neighborhood: d.neighborhood_9,
                ur_acms: d.Q100_1_URACMS
            };
        };

        var radialScale = d3.scaleLog()
            .domain([.002, 10000])
            .range([0, chartWidth / 2 - padding]);

        var ticks_set = [.01, 10, 100, 1000, 10000];

        function angleToCoordinate(angle, value) {
            var x = Math.cos(angle) * radialScale(value);
            var y = Math.sin(angle) * radialScale(value);
            return { "x": x, "y": y }; // Remove offset to center in the group
        }

        function polarCoords(value, index, list) {
            var angle = Math.PI / 2 + ((index * 2 * Math.PI) / (list.length));
            return angleToCoordinate(angle, value);
        }

        var chartContainer = d3.select("#chart-container");
        var legendContainer = d3.select("#legend-container");

        function updateChart(selectedCity, selectedNeighborhood) {
            chartContainer.selectAll("*").remove();
            legendContainer.selectAll("*").remove();
            d3.select("#chart-title-container").selectAll("*").remove(); // Clear existing title container
            d3.select("#chart-subtext-container").selectAll("*").remove(); // Clear existing subtext container

            var filteredData = dataset.filter(d => (selectedCity === "all" || d.current_city.toLowerCase() === selectedCity) &&
                (selectedNeighborhood === "all" || d.neighborhood.toLowerCase() === selectedNeighborhood));

            // Filter out data points with NaN cumulative_dist
            filteredData = filteredData.filter(d => !isNaN(d.cumulative_dist));

            // Sort data first by ur_acms (category/color) and then by cumulative_dist
            filteredData.sort((a, b) => {
                if (categoryColors[a.ur_acms] < categoryColors[b.ur_acms]) return -1;
                if (categoryColors[a.ur_acms] > categoryColors[b.ur_acms]) return 1;
                return b.cumulative_dist - a.cumulative_dist;
            });

            var svg = chartContainer.append("svg")
                .attr("width", 400)
                .attr("height", 400);

            var circle_group = svg.append("g")
                .attr("class", "chart")
                .attr("transform", "translate(" + chartWidth / 2 + "," + chartHeight / 2 + ")"); // Center the group

            var lines = circle_group.append("g")
                .attr("class", "lines");

            lines.selectAll("line")
                .data(filteredData)
                .enter()
                .append("line")
                .attr("x1", 0)
                .attr("x2", (d, i, n) => polarCoords(d.cumulative_dist, i, n).x)
                .attr("y1", 0)
                .attr("y2", function (d, i, n) {
                    var coordinate = polarCoords(d.cumulative_dist, i, n).y;
                    return coordinate;
                })
                .attr("stroke", d => categoryColors[d.ur_acms])
                .attr("stroke-width", .5)
                .on("mouseover", function (event, d) {
                    d3.select("#tooltip")
                        .select("#val")
                        .text(d.ur_acms + " dist: " + d.cumulative_dist + " Respondent " + d.resp_id + " is from " + d.city + ", " + d.country_orig + " which is " + d.cumulative_dist + " kilometers away from " + d.current_city);
                    d3.select("#tooltip").classed("hidden", false);
                })
                .on("mouseout", function () {
                    d3.select("#tooltip").classed("hidden", true);
                });

            var scale = circle_group.append("g")
                .attr("class", "scale");
            scale.selectAll("circle")
                .data(ticks_set)
                .enter()
                .append("circle")
                .attr("class", "scale")
                .attr("id", (d, i) => "fixed-dist" + i)
                .attr("cx", 0)
                .attr("cy", 0)
                .attr("fill", "none")
                .attr("r", d => radialScale(d))
                .attr("stroke-width", .25);

            scale.selectAll("text")
                .data(ticks_set)
                .enter()
                .append("text")
                .attr("x", 0)
                .attr("y", d => -radialScale(d))
                .text(d => d + " km")
                .attr("class", "scale-path")
                .attr("text-anchor", "middle"); // Center the text

            var scale_relative = circle_group.append("g")
                .attr("class", "scale_rel");

            var dist_markers = distanceMarkers[selectedCity.charAt(0).toUpperCase() + selectedCity.slice(1)] || [];

            scale_relative.selectAll("circle")
                .data(dist_markers)
                .enter()
                .append("circle")
                .attr("class", "scale-dashed")
                .attr("id", (d, i) => "cities-dist" + d.dist)
                .attr("cx", 0)
                .attr("cy", 0)
                .attr("fill", "none")
                .attr("r", function (d) {
                    return radialScale(d.dist);
                })
                .attr("stroke-width", .5);

            scale_relative.selectAll("text")
                .data(dist_markers)
                .enter()
                .append("text")
                .attr("x", d => -radialScale(d.dist))
                .attr("y", d => chartHeight / 2 - radialScale(d.dist))
                .text(d => d.name + ", " + d.dist + " km")
                .attr("class", "scale-path")
                .attr("text-anchor", "left");

            // City-specific examples for each category
            var cityExamples = {
                'accra': {
                    'City': ["Madina, Ghana", "Bamako, Mali"],
                    'Town': ["Gushiegu, Ghana", "Enugu, Nigeria"],
                    'Village': ["Yendi, Ghana", "Sokode, Togo"]
                },
                'nairobi': {
                    'City': ["Mwanza, Tanzania", "Khartoum, Sudan"],
                    'Town': ["Wote, Kenya", "Garissa, Kenya"],
                    'Village': ["Siaya, Kenya", "Minembwe, D.R.C."]
                },
                'johannesburg': {
                    'City': ["Mwanza, Tanzania", "Khartoum, Sudan"],
                    'Town': ["Wote, Kenya", "Garissa, Kenya"],
                    'Village': ["Kranskop, South Africa", "Mzimba, Malawi"]
                }
            };

            var examples = cityExamples[selectedCity] || cityExamples[''];

            // Update legends
            updateLeftLegend(filteredData);
            updateRightLegend(examples, filteredData, selectedCity);

            if (selectedCity !== 'all') {
                d3.select("#chart-title-container").append("div")
                    .attr("class", "chart-title")
                    .text(`Urban vs. Rural Origins to ${capitalizeFirstLetter(selectedCity)}, by density`);

                d3.select("#chart-subtext-container").append("div")
                    .attr("class", "chart-subtext")
                    .text(`Urban-Rural Categorization of migration paths for respondents currently living in ${capitalizeFirstLetter(selectedCity)}, using the WPP definition of "urban" as having 300 or more people per square kilometer.`);
            }
        }

        function updateLeftLegend(filteredData) {
            var leftLegendContainer = d3.select("#left-legend-container");
            leftLegendContainer.selectAll("*").remove();

            var totalResponses = filteredData.length;
            var categoryCounts = d3.rollup(filteredData, v => v.length, d => d.ur_acms);

            var urbanCount = categoryCounts.get('City') || 0;
            var townCount = categoryCounts.get('Town') || 0;
            var villageCount = categoryCounts.get('Village') || 0;
            var unclassifiedCount = totalResponses - urbanCount - townCount - villageCount;

            var legendCombinedContainer = leftLegendContainer.append("div")
                .attr("class", "legend-combined-container");

            var legendHeaderContainer = legendCombinedContainer.append("div")
                .attr("class", "legend-header-container");

            legendHeaderContainer.append("div")
                .attr("class", "legend-header")
                .text("U.N. WPP");

            legendHeaderContainer.append("div")
                .attr("class", "legend-subtext")
                .text("> 300k pop / km²");

            var legendTitleContainer = legendCombinedContainer.append("div")
                .attr("class", "legend-title-container");

            legendTitleContainer.append("div")
                .attr("class", "legend-header")
                .text("100: Village, City, or Town");

            var legendSVGContainer = leftLegendContainer.append("div")
                .attr("class", "legend-svg-container");

            var legendSVG = legendSVGContainer.append("svg")
                .attr("width", 300)
                .attr("height", 120);

            var legendGroup = legendSVG.append("g")
                .attr("transform", "translate(10, 40)");

            // Labels for categories
            legendGroup.append("text")
                .attr("x", 50)
                .attr("y", 0)
                .attr("class", "legend-category")
                .attr("text-anchor", "middle")
                .text("people");

            legendGroup.append("text")
                .attr("x", 150)
                .attr("y", 0)
                .attr("class", "legend-category")
                .attr("text-anchor", "middle")
                .text("city");

            legendGroup.append("text")
                .attr("x", 200)
                .attr("y", 0)
                .attr("class", "legend-category")
                .attr("text-anchor", "middle")
                .text("town");

            legendGroup.append("text")
                .attr("x", 250)
                .attr("y", 0)
                .attr("class", "legend-category")
                .attr("text-anchor", "middle")
                .text("village");

            // People count with line
            legendGroup.append("text")
                .attr("x", 50)
                .attr("y", 40)
                .attr("class", "legend-number")
                .attr("text-anchor", "middle")
                .text(totalResponses);

            legendGroup.append("line")
                .attr("x1", 90)
                .attr("y1", 36)
                .attr("x2", 140)
                .attr("y2", 36)
                .attr("stroke", "black")
                .attr("stroke-width", 1);

            legendGroup.append("text")
                .attr("x", 90)
                .attr("y", 40)
                .attr("class", "legend-label")
                .attr("text-anchor", "start")

            // City count
            legendGroup.append("rect")
                .attr("x", 140)
                .attr("y", 20)
                .attr("width", 40)
                .attr("height", 40)
                .attr("fill", cityColor);

            legendGroup.append("text")
                .attr("x", 160)
                .attr("y", 45)
                .attr("class", "legend-number")
                .attr("text-anchor", "middle")
                .text(urbanCount);

            // Line connecting city to town
            legendGroup.append("line")
                .attr("x1", 180)
                .attr("y1", 36)
                .attr("x2", 280)
                .attr("y2", 36)
                .attr("stroke", "black")
                .attr("stroke-width", 1);

            // Line under legend 
            legendGroup.append("line")
                .attr("x1", 25)
                .attr("y1", 72)
                .attr("x2", 280)
                .attr("y2", 72)
                .attr("stroke", "black")
                .attr("stroke-width", 1);

            // Town count
            legendGroup.append("rect")
                .attr("x", 190)
                .attr("y", 20)
                .attr("width", 40)
                .attr("height", 40)
                .attr("fill", townColor);

            legendGroup.append("text")
                .attr("x", 210)
                .attr("y", 45)
                .attr("class", "legend-number")
                .attr("text-anchor", "middle")
                .text(townCount);

            // Line connecting town to village
            legendGroup.append("line")
                .attr("x1", 240)
                .attr("y1", 36)
                .attr("x2", 280)
                .attr("y2", 36)
                .attr("stroke", "black")
                .attr("stroke-width", 1);

            // Village count
            legendGroup.append("rect")
                .attr("x", 240)
                .attr("y", 20)
                .attr("width", 40)
                .attr("height", 40)
                .attr("fill", villageColor);

            legendGroup.append("text")
                .attr("x", 260)
                .attr("y", 45)
                .attr("class", "legend-number")
                .attr("text-anchor", "middle")
                .text(villageCount);

            // Adding other text elements
            var details = [
                { label: 'urban', value: urbanCount },
                { label: 'unclassified', value: unclassifiedCount },
                { label: 'non-urban', value: townCount + villageCount },
            ];

            details.forEach(detail => {
                var detailContainer = leftLegendContainer.append("div")
                    .attr("class", "legend-detail-container");

                detailContainer.append("div")
                    .attr("class", "legend-subtext-2")
                    .text(detail.label);

                detailContainer.append("div")
                    .attr("class", "legend-number")
                    .text(detail.value);
            });
        }


        function updateRightLegend(examples, filteredData, selectedCity) {
            var rightLegendContainer = d3.select("#right-legend-container");
            rightLegendContainer.selectAll("*").remove();

            var totalResponses = filteredData.length;
            var categoryCounts = d3.rollup(filteredData, v => v.length, d => d.ur_acms);

            var urbanCount = categoryCounts.get('City') || 0;
            var townCount = categoryCounts.get('Town') || 0;
            var villageCount = categoryCounts.get('Village') || 0;
            var unclassifiedCount = totalResponses - urbanCount - townCount - villageCount;

            var urbanPercentage = ((urbanCount / totalResponses) * 100).toFixed(1);
            var townPercentage = ((townCount / totalResponses) * 100).toFixed(1);
            var villagePercentage = ((villageCount / totalResponses) * 100).toFixed(1);

            rightLegendContainer.append("div")
                .attr("class", "legend-title")
                .text("Percentages of migration origins");

            rightLegendContainer.append("div")
                .attr("class", "legend-subtext")
                .text("100: Village, City, or Town");

            var legendData = [
                { category: "City", color: cityColor, percentage: urbanPercentage + "%", examples: examples['City'] },
                { category: "Town", color: townColor, percentage: townPercentage + "%", examples: examples['Town'] },
                { category: "Village", color: villageColor, percentage: villagePercentage + "%", examples: examples['Village'] }
            ];

            legendData.forEach(item => {
                var legendItem = rightLegendContainer.append("div")
                    .attr("class", "legend-item");

                legendItem.append("div")
                    .attr("class", "legend-color")
                    .style("background-color", item.color)
                    .style("width", "18px")
                    .style("height", "18px");

                var textContainer = legendItem.append("div")
                    .attr("class", "legend-text");

                textContainer.append("div")
                    .attr("class", "legend-category")
                    .html(`<span>${item.category}</span><span class="legend-percentage">${item.percentage}</span>`);

                textContainer.append("div")
                    .attr("class", "legend-subtext")
                    .html(`i.e ${item.examples.join(", ")}`);
            });
        }

        function capitalizeFirstLetter(string) {
            return string.charAt(0).toUpperCase() + string.slice(1);
        }

        var dataset;

        d3.csv("data/star_origins_UR.csv", rowConverter).then(function (data) {
            dataset = data;

            var cities = Array.from(new Set(data.map(d => d.current_city)));
            cities.unshift("All"); // Capitalize "All"
            var citySelect = d3.select("#city-select");

            citySelect.selectAll("option")
                .data(cities)
                .enter()
                .append("option")
                .text(d => d)
                .attr("value", d => d.toLowerCase());

            citySelect.on("change", function () {
                var selectedCity = d3.select(this).property("value").toLowerCase();

                var neighborhoods = Array.from(new Set(dataset.filter(d => selectedCity === "all" || d.current_city.toLowerCase() === selectedCity).map(d => d.neighborhood)));
                neighborhoods = neighborhoods.filter(n => n !== '-3'); // Exclude "-3" neighborhood
                neighborhoods.unshift("All"); // Capitalize "All"
                var neighborhoodSelect = d3.select("#neighborhood-select");

                neighborhoodSelect.selectAll("option").remove();
                neighborhoodSelect.selectAll("option")
                    .data(neighborhoods)
                    .enter()
                    .append("option")
                    .text(d => d)
                    .attr("value", d => d.toLowerCase());

                neighborhoodSelect.on("change", function () {
                    var selectedNeighborhood = d3.select(this).property("value").toLowerCase();
                    updateChart(selectedCity, selectedNeighborhood);
                    filterPolylines(); // Update the map when the neighborhood is changed
                });

                // Update chart for the first neighborhood
                neighborhoodSelect.property("value", "all").dispatch("change");
            });

            // Initial chart rendering for "all" city and "all" neighborhood
            citySelect.property("value", "all").dispatch("change");
        }).catch(function (error) {
            console.error('Error loading or parsing data:', error);
        });

        function downloadSVG() {
            var svgElement = document.querySelector("#map svg"); // Select the SVG element

            // Create a blob from the SVG XML
            var svgBlob = new Blob([svgElement.outerHTML], { type: "image/svg+xml;charset=utf-8" });
            var svgUrl = URL.createObjectURL(svgBlob);
            var downloadLink = document.createElement("a");
            downloadLink.href = svgUrl;
            downloadLink.download = "visualization.svg";

            // Trigger the download
            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);
        }

        function downloadLegendPNG() {
            var legendElement = document.querySelector("#legend");
            
            html2canvas(legendElement).then(canvas => {
                var imgData = canvas.toDataURL('image/png');
                var downloadLink = document.createElement("a");
                downloadLink.href = imgData;
                downloadLink.download = "legend.png";

                // Trigger the download
                document.body.appendChild(downloadLink);
                downloadLink.click();
                document.body.removeChild(downloadLink);
            });
        }

        function downloadLegend() {
    var legendElement = document.querySelector("#legend");
    var svgWidth = legendElement.offsetWidth;
    var svgHeight = legendElement.offsetHeight;

    var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.setAttribute("width", svgWidth);
    svg.setAttribute("height", svgHeight);
    svg.setAttribute("xmlns", "http://www.w3.org/2000/svg");

    appendDivAsSvgElement(svg, document.querySelector("#left-legend-container"), 0, 0);
    appendDivAsSvgElement(svg, document.querySelector("#right-legend-container"), 300, 0);
    appendDivAsSvgElement(svg, document.querySelector("#chart-container"), 600, 0);
    appendDivAsSvgElement(svg, document.querySelector("#chart-title-container"), 600, 200);
    appendDivAsSvgElement(svg, document.querySelector("#chart-subtext-container"), 600, 250);

    var serializer = new XMLSerializer();
    var svgBlob = new Blob([serializer.serializeToString(svg)], { type: "image/svg+xml;charset=utf-8" });
    var svgUrl = URL.createObjectURL(svgBlob);
    var downloadLink = document.createElement("a");
    downloadLink.href = svgUrl;
    downloadLink.download = "legend.svg";

    // Trigger the download
    document.body.appendChild(downloadLink);
    downloadLink.click();
    document.body.removeChild(downloadLink);
}

function appendDivAsSvgElement(svg, divElement, offsetX, offsetY) {
    var foreignObject = document.createElementNS("http://www.w3.org/2000/svg", "foreignObject");
    foreignObject.setAttribute("width", divElement.offsetWidth);
    foreignObject.setAttribute("height", divElement.offsetHeight);
    foreignObject.setAttribute("x", offsetX);
    foreignObject.setAttribute("y", offsetY);

    var div = document.createElement("div");
    div.setAttribute("xmlns", "http://www.w3.org/1999/xhtml");
    div.style.width = divElement.offsetWidth + "px";
    div.style.height = divElement.offsetHeight + "px";

    var clonedDiv = divElement.cloneNode(true);
    inlineAllStyles(clonedDiv);
    div.appendChild(clonedDiv);

    foreignObject.appendChild(div);
    svg.appendChild(foreignObject);
}

function inlineAllStyles(element) {
    var allElements = element.querySelectorAll("*");
    allElements.forEach(function(el) {
        var computedStyle = getComputedStyle(el);
        var styleString = "";
        for (var key of computedStyle) {
            if (computedStyle.getPropertyValue(key)) {
                styleString += key + ":" + computedStyle.getPropertyValue(key) + ";";
            }
        }
        el.setAttribute("style", styleString);
    });
}

document.getElementById("download-svg").addEventListener("click", downloadSVG);
document.getElementById("download-legend").addEventListener("click", downloadLegend);


</script>
</body>
</html>