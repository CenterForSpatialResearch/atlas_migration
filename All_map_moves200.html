<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>Map and Star Chart</title>
    <!-- <script src="https://d3js.org/d3.v7.min.js"></script> --> 
    <script src="js/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <link rel="stylesheet" href="main.css">
</head>

<body>
    <!-- <div style="display:grid; width:90vw; height:90vh;"> -->
                <div id="tooltip" class="hidden">
                    <p><span id="val"></span></p>
                </div>

                <div id="filter-container">
                    <label for="city-select">Zoom to City: </label>
                    <select id="city-select">
                        <option value="all">All</option>
                        <option value="Johannesburg">Johannesburg</option>
                        <option value="Nairobi">Nairobi</option>
                        <option value="Accra">Accra</option>
                    </select>

                    <label for="neighborhood-select">Select Neighborhood: </label>
                    <select id="neighborhood-select">
                        <option value="all">All</option>
                    </select>

                    <label for="moves-select">Filter by Number of Moves: </label>
                    <select id="moves-select">
                        <option value="all">All</option>
                        <option value="1">1 Move</option>
                        <option value="2">2 Moves</option>
                        <option value="3">3 Moves</option>
                        <option value="4">4 Moves</option>
                        <option value="5">5 Moves</option>
                    </select>
                    <!-- <button id="download-page">Download SVG page</button> -->
                    <!-- <button id="download-svg">Download map SVG</button> -->
                    <!-- <button id="download-legend">Download Legend SVG</button> -->
                    <!-- <button id="download-png-button">Download PNG</button> -->
                    <!-- <button onclick="downloadLegendPNG()">Download Legend PNG</button> -->

                </div>
                <div class="container" id="print-container">
                    <div id="map"></div>
                    <div id="legend">
                        <div id="left-legend-container"></div>
                        <div id="right-legend-container"></div>
                        <div id="chart-container"></div>
                        <div id="chart-title">
                            <div id="people-legend"></div>
                            <div id="chart-title-container"></div>
                            <div id="chart-subtext-container"></div>
                        </div>
                        <div id="line" class="line"></div>
                        <div id="arc" class="path"></div>
                    </div>
                </div>
     <!-- </div> -->
</body>

    <!-- script -->
    <script type="text/javascript">
        var mapContainer = document.getElementById('map');
        var width = mapContainer.offsetWidth;
        var height = mapContainer.offsetHeight;

        // var projection = d3.geoMercator()
        // var projection = d3.geoAzimuthalEqualArea() // for globe view
        var projection = d3.geoAzimuthalEquidistant() //for zoom in views
            .center([0, -20])
            .scale([1500])
            .translate([width / 2, height / 2]);

        var path = d3.geoPath()
            .projection(projection);

        var svg = d3.select("#map").append("svg")
            .attr("width", width)
            .attr("height", height);

        var cityColor = "#f8961d";
        var townColor = "#e0c300";
        var villageColor = "#98b759";

        var colorDict = {'-19': '#2B1766',
                            'Algeria': '#D1556B',
                            'Angola': '#AA3A5D',
                            'Australia': '#83CDCA',
                            'Bangladesh': '#418DC1',
                            'Belgium': '#EFA747',
                            'Benin': '#5EE0B6',
                            'Botswana': '#00FDE5',
                            'Burkina Faso': '#B34F93',
                            'Burundi': '#4072E6',
                            'Cameroon': '#426CF7',
                            'Canada': '#A50816',
                            'Cape Coast': '#A75549',
                            'China': '#0FB1D2',
                            'Chingola': '#7AD87D',
                            'Colombia': '#22683F',
                            'Czech Republic': '#AADC25',
                            "Ivory Coast": '#ff00f7',
                            'Democratic Republic of the Congo': '#CAC17D',
                            'Egypt': '#08A0B2',
                            'Eswatini': '#47C951',
                            'Ethiopia':'#ffc50e',
                            'France': '#451B19',
                            'Gabon': '#AA1047',
                            'Germany': '#79DD19',
                            'Ghana': '#fa9600',
                            'Greece': '#BC7263',
                            'Hungary': '#B69C09',
                            'India': '#A8106C',
                            'Iran': '#16C4A0',
                            'Iraq': '#D54689',
                            'Israel': '#5E67B2',
                            'Italy': '#E259DE',
                            'Japan': '#91DA83',
                            'Kenya': '#98b759',
                            'Kiambu': '#A8BE57',
                            'Kisii': '#352664',
                            'Kitale': '#5B3F52',
                            'Kumasi': '#F70D2A',
                            'KwaZulu-Natal': '#A6A0FA',
                            'Lesotho': '#BDF5F1',
                            'Liberia': '#73C471',
                            'Libya': '#8B7827',
                            'Malawi':'#BA845A',
                            'Malaysia': '#58DDC7',
                            'Mali': '#2B728F',
                            'Mombasa': '#A8E55A',
                            'Morocco': '#618564',
                            'Mozambique':'#ff9896',
                            'Netherlands': '#E1B448',
                            'New Zealand': '#F7185A',
                            'Nicaragua': '#3E4CB0',
                            'Niger': '#9C69DB',
                            'Nigeria': '#17becf',
                            'None': '#7E00CA',
                            'Norway': '#89C861',
                            'Nyeri': '#68BBAA',
                            'Oman': '#B5730E',
                            'Pakistan': '#632D41',
                            'Qatar': '#626176',
                            'Republic of the Congo': '#282585',
                            'Russia': '#9C9FA4',
                            'Rwanda': '#2E1EB8',
                            'Saudi Arabia': '#1B7E63',
                            'Senegal': '#0C068A',
                            'Seychelles': '#F8EB02',
                            'Siaya': '#B31590',
                            'Sierra Leone': '#0FCF9E',
                            'Singapore': '#C0AFE4',
                            'Somalia': '#4FCDA8',
                            'South Africa':'#24709E',
                            'South Korea': '#F2D8C0',
                            'South Sudan': '#495D3A',
                            'Spain': '#E456A7',
                            'Sudan': '#1BA0C1',
                            'Sweden': '#E42410',
                            'Switzerland': '#5EFDA6',
                            'Tana River': '#F32282',
                            'Tanzania':'#e014c9',
                            'Thika': '#880E17',
                            'Togo': '#E1D4EE',
                            'Turkey': '#9AD959',
                            'Uganda': '#c5b0d5',
                            'United Arab Emirates': '#233296',
                            'United Kingdom': '#3E61FE',
                            'United States': '#572bbd',
                            'Zambia': '#695DEF',
                            'Zimbabwe': '#908ACF',
                            'nan': '#E12991'};

        var cityCoordinates = {
            'Johannesburg': [28.0473, -26.2041],
            'Nairobi': [36.8219, -1.2921],
            'Accra': [-0.1870, 5.6037],
            'all': [0, 10]
        };


        var validNairobiNeighborhoods = new Set(["Kawangware", "Kayole", "Ongata Rongai"]);

        var distanceMarkers = {
            "Nairobi": [
                { location: "Nairobi", dist: 2900, name: "Johannesburg, South Africa" },
                { location: "Nairobi", dist: 500, name: "Kampala, Uganda" },
                { location: "Nairobi", dist: 60, name: "Machakos, Kenya" }
            ],
            "Accra": [
                { location: "Accra", dist: 400, name: "Lagos, Nigeria" },
                { location: "Accra", dist: 4300, name: "Nairobi, Kenya" },
                { location: "Accra", dist: 160, name: "Lome, Togo" }
            ],
            "Johannesburg": [
                { location: "Johannesburg", dist: 3456, name: "Addis Ababa, Ethiopia" },
                { location: "Johannesburg", dist: 450, name: "Maputo, Mozambique" },
                { location: "Johannesburg", dist: 50, name: "Pretoria, South Africa" }
            ]
        };

        // Global variables
        var polylines = []; // Array to store polylines
        var neighborhoodsByCity = {}; // Object to store neighborhoods by city
        var migrations = []; // Global migrations variable

        Promise.all([
            d3.json("data/ref/countries-10m.geo.json"), // High resolution
            // d3.json("data/ref/world_countries.geo.json"), // Low resolution
            // d3.json("data/ref/world-urban-polygons.geojson"), //remove for web version
            d3.json("data/ref/h2o-.geo.json"),
            d3.csv("data/origin_migrations_UR.csv"), // TODO  remove This data will have the data of num_move and the type of migration
            d3.csv("data/location_data.csv"), //TODO remove Load the location_data.csv file
            d3.csv("data/origin-to-neighborhood_UR.csv"), // Load combined data updated csv
            d3.csv("data/moves200.csv") 
        ]).then(function (data) {
            var highResWorld = data[0];
            var waterBodies = data[1];
            var originMigrations = data[2];
            locationData = data[3]; // Store location data globally
            var origin_migrations_UR = data[4];
            var moves200 = data[5];

            // console.log(moves200);
            
            
                svg.append("g")
                    .selectAll("path")
                    .data(highResWorld.features)
                    .enter()
                    .append("path")
                    .attr("d", path)
                    .attr("fill", "#f0f0f0")
                    .attr("stroke", "#d1d1d1")
                    .attr("stroke-width", .5);

                svg.append("g")
                    .selectAll("path")
                    .data(waterBodies.features)
                    .enter()
                    .append("path")
                    .attr("d", path)
                    .attr("fill", "#ffffff")
                    .attr("stroke", "#ffffff")
                    .attr("stroke-width", .25);

                var locationToNeighborhood = createLocationToNeighborhoodMapping(moves200);
                populateNeighborhoodsByCity(moves200, locationToNeighborhood);
                ready(moves200, originMigrations, locationToNeighborhood);

                var graticule = d3.geoGraticule().step([1, 1]); // degrees - default 10 if not set
                var gridLines = svg.append("g").attr("class", "graticule");

                gridLines.append("path")
                    .datum(graticule)
                    .attr("class", "graticule")
                    .attr("d", path)
                    .attr("stroke", "#d6d6d6")
                    .attr("stroke-width", .25)
                    .attr("fill", "none");

                }).catch(function (error) {
                console.error('Error loading data:', error);
                });

                // Helper: Create mapping from location to neighborhood
            function createLocationToNeighborhoodMapping(data) {
                    var mapping = {};
                    data.forEach(function (d) {
                        var loc = d["9_location"];
                        if (loc) {
                            var neighborhood = loc?.match(/'([^']+)'/)?.[1] || 'Unknown';
                            mapping[loc] = neighborhood;
                        }
                    });
                    return mapping;
                }

                // Helper: Populate neighborhoods grouped by city
            function populateNeighborhoodsByCity(moves200, locationToNeighborhood) {
                    moves200.forEach(function (migration) {
                        var location = migration["9_location"];
                        var neighborhood = location?.match(/'([^']+)'/)?.[1] || 'Unknown';
                        var city = location?.match(/'[^']*',\s*'([^']*)'/)?.[1];

                        if (city === 'Nairobi' && !validNairobiNeighborhoods.has(neighborhood)) {
                            return;
                        }

                        if (!neighborhoodsByCity[city]) {
                            neighborhoodsByCity[city] = new Set();
                        }
                        neighborhoodsByCity[city].add(neighborhood);
                    });
                }

            function updateNeighborhoodDropdown(city) {
                var neighborhoodSelect = document.getElementById('neighborhood-select');
                neighborhoodSelect.innerHTML = '<option value="all">All</option>'; // Capitalize "All"

                if (neighborhoodsByCity[city]) {
                    neighborhoodsByCity[city].forEach(function (neighborhood) {
                        var option = document.createElement('option');
                        option.value = neighborhood;
                        option.text = neighborhood;
                        neighborhoodSelect.appendChild(option);
                    });
                }
                }

            function ready(moves200,loadedMigrations, locationToNeighborhood) {
                migrations = moves200; // Ensure this is the global migrations variable
                
                migrations.forEach(function(migration) {
                    var location = migration["9_location"];
                    var neighborhood = location?.match(/'([^']+)'/)?.[1] || 'Unknown';
                    var city = location?.match(/'[^']*',\s*'([^']*)'/)?.[1];

                            if (cityCoordinates[city]) {
                                var color = colorDict[migration.originColor] || "#000000";
                                var neighborhood = locationToNeighborhood[location] || 'Unknown';
                                if (city === 'Nairobi' && !validNairobiNeighborhoods.has(neighborhood)) {
                                    return;
                                }

                                var points = [];
                                var keys = [ "100", "202", "202.1", "202.2", "202.3", "202.4", "206", "211", "214", "215","9"];
                                keys.forEach(key => {
                                    let lat = migration[`${key}_lat`];
                                    let lon = migration[`${key}_lon`];
                                    if (lat && lon && lat !== "#N/A" && lon !== "#N/A") {
                                        points.push(([+lat,+lon,]));
                                    }
                                });

                                var path = d3.geoPath().projection(projection);

                                // Loop through the points and draw an arc between each consecutive pair of points
                                for (let i = 0; i < points.length - 1; i++) {
                                    // Project the coordinates
                                    var startPoint = projection([points[i][0], points[i][1]]);
                                    var endPoint = projection([points[i + 1][0], points[i + 1][1]]);

                                    var arcPath = createArcPath(startPoint, endPoint);

                                        var lineData = {
                                            ID: migration.ID,
                                            city: city,
                                            neighborhood: neighborhood,
                                            points: points,
                                            path: arcPath,
                                            loc: migration["100_location"],
                                            lat: migration["100_lat"], //for aerial imagery
                                            lon: migration["100_lon"],
                                            current: migration["9_location"],
                                            loc1: migration["202_location"],
                                            loc2: migration["202.1_location"],
                                            loc3: migration["202.2_location"],
                                            loc4: migration["202.3_location"],
                                            loc5: migration["202.4_location"],
                                            loc6: migration["206_location"],
                                            loc7: migration["211_location"],
                                            loc8: migration["214_location"],
                                            loc9: migration["215_location"],
                                            color: colorDict[migration.originColor],
                                            moves: migration.nummoves
                                        };

                                        // Draw the arc between consecutive points
                                        var mapPath = svg.append("path")
                                            .datum(arcPath)  // Attach the arc path data
                                            .attr("d", arcPath)  // Set the path 'd' attribute
                                            .attr("fill", "none")
                                            .attr("stroke", color)
                                            // .attr("stroke", "url(#" + gradientId + ")")
                                            .attr("stroke-width", 0.3) 
                                            // .attr("opacity", 0.7)
                                            .attr("z-index", 100)
                                            .datum(lineData)
                                            .attr("class", "arc-path");  // Attach migration data to path

                                        polylines.push(mapPath);
                                    }
                            }
                        });

                filterPolylines(); // Initialize filters
                }

            // Function to create an arc path between two points (start and end)
        function createArcPath(start, end) {
                    var dx = end[0] - start[0];
                    var dy = end[1] - start[1];
                    var dist = Math.sqrt(dx * dx + dy * dy);
                    var factor = 0.2;

                    var controlPoint = [
                        (start[0] + end[0]) / 2 + factor * dist * (dy / dist), 
                        (start[1] + end[1]) / 2 - factor * dist * (dx / dist)
                    ];

                    return d3.line()
                        .curve(d3.curveBasis)
                        .x(d => d[0])
                        .y(d => d[1])
                        ([start, controlPoint, end]);
                }
                //TODO for opacity gradient
                // function createOpacityGradient(strokeColor) {
                //         // Convert hex color to RGB
                //         var rgb = hexToRgb(strokeColor);

                //         // Create a unique gradient ID based on the stroke color
                //         var gradientId = "opacity-gradient-" + strokeColor.replace('#', '');

                //         // Append the gradient definition to defs
                //         svg.append("defs")
                //             .append("linearGradient")
                //             .attr("id", gradientId)
                //             .attr("gradientUnits", "userSpaceOnUse")
                //             .attr("x1", 0).attr("y1", 0)  // Start of the path
                //             .attr("x2", 1).attr("y2", 0)  // End of the path
                //             .selectAll("stop")
                //             .data([
                //                 { offset: "0%", color: `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.2)` }, // 20% opacity
                //                 { offset: "100%", color: `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 1)` } // 100% opacity
                //             ])
                //             .enter().append("stop")
                //             .attr("offset", d => d.offset)
                //             .attr("stop-color", d => d.color);

                //         return gradientId;
                //     }

                //     // Function to convert hex to rgb
                //     function hexToRgb(hex) {
                //         var r = parseInt(hex.slice(1, 3), 16);
                //         var g = parseInt(hex.slice(3, 5), 16);
                //         var b = parseInt(hex.slice(5, 7), 16);
                //         return { r: r, g: g, b: b };
                //     }

        

         document.getElementById('city-select').addEventListener('change', function () {
                var selectedCity = this.value.toLowerCase();

                if (!selectedCity) {
                        console.log("Error: No city selected!");
                    }
                updateNeighborhoodDropdown(selectedCity);
                filterPolylines();
                zoomToCity(selectedCity);

                });

        document.getElementById('neighborhood-select').addEventListener('change', function () {
                filterPolylines();
                });

        document.getElementById('moves-select').addEventListener('change', filterPolylines);

        function filterPolylines() {
                var selectedCity = document.getElementById('city-select').value.toLowerCase();
                var selectedNeighborhood = document.getElementById('neighborhood-select').value.toLowerCase();
                var selectedMoves = document.getElementById('moves-select').value;

                svg.selectAll("text").remove(); // Remove all text labels first
                svg.selectAll(".arc-path").remove();

                var newPolylines = [];
                var locationsWithPolylines = [];  
                // if (migrations.length === 0) {
                // console.warn('No migrations data available.');
                // return;
                // }

            polylines.forEach(function (line) {
                var lineData = line.datum();

                if (!lineData || !lineData.city || !lineData.moves) {
                        console.warn("Skipping invalid line data:", lineData);
                        return;
                    }
                    // console.log("lineData",lineData.city);
                    
                    // Check if city and neighborhood match the selected values
                var cityMatches = selectedCity === 'all' || lineData.city.toLowerCase() === selectedCity;
                var neighborhoodMatches = selectedNeighborhood === 'all' || lineData.neighborhood.toLowerCase() === selectedNeighborhood;
                var movesMatches = selectedMoves === 'all' || parseInt(lineData.moves) === parseInt(selectedMoves);
            

                if (cityMatches && neighborhoodMatches && movesMatches) {
                    // Iterate through the points to create arcs between consecutive points
                    for (let i = 0; i < lineData.points.length - 1; i++) {
                        // Project the coordinates
                        var startPoint = projection([lineData.points[i][0], lineData.points[i][1]]);
                        var endPoint = projection([lineData.points[i + 1][0], lineData.points[i + 1][1]]);
                        var arcPath = createArcPath(startPoint, endPoint);

                    // TODO for opacity gradient
                    // var strokeColor = line.attr("stroke");
                    // var gradientId = createOpacityGradient(strokeColor);

                    // Append the path and apply the unique gradient
                    var mapLine = svg.append("path")
                        .datum(lineData)
                        .attr("d", arcPath)  // Set the path 'd' attribute
                        .attr("fill", "none")
                        .attr("stroke", lineData.color)
                        // .attr("stroke", "url(#" + gradientId + ")")  // Use the unique gradient ID
                        .attr("stroke-width", line.attr("stroke-width"))
                        .attr("z-index", 100)
                        .attr("class", "arc-path");  // Add a class for easy selection

                                // Thicker Transparent line for interaction
                                svg.append("path")
                                    .datum(lineData)
                                    .attr("d", arcPath)  // Set the path 'd' attribute
                                    .attr("stroke", "transparent")
                                    // .attr("stroke", line.attr("stroke")) // use to show lines
                                    .attr("fill", "none")
                                    .attr("stroke-width", Math.max(line.attr("stroke-width") * 4, 8))
                                    .on("mouseover", function (event, d) {
                                        generateTooltipWithImage(d); // Generate the tooltip with the image
                                        d3.select("#tooltip").classed("hidden", false);  // Show the tooltip
                                    });

                            // newPolylines.push(mapLine);
                            polylines.push(mapLine);
                        }
                        }
                    });

                    // polylines = newPolylines; 

                // Draw labels for locations, using the matched location or 'unknown'
                locationsWithPolylines.forEach(function(item) {
                    svg.append("text")
                        .attr("x", item.endPoint[0])
                        .attr("y", item.endPoint[1])
                        .attr("class", "origin-text")
                        .attr("dy", ".35em")
                        .text(item.location);
                });
                }
                function generateTooltipWithImage(lineData) {
                    let tooltipText = `Respondent: ${lineData.ID} moved ${lineData.moves} times from ${lineData.loc.replace(/[()\[\]']/g, '')} to ${lineData.current.replace(/[()\[\]']/g, '')} <br><br>`;

                const validLocations = [];
                if (lineData.loc2 && lineData.loc2 !== "#N/A") validLocations.push(lineData.loc2.replace(/[()\[\]']/g, ''));
                if (lineData.loc3 && lineData.loc3 !== "#N/A") validLocations.push(lineData.loc3.replace(/[()\[\]']/g, ''));
                if (lineData.loc4 && lineData.loc4 !== "#N/A") validLocations.push(lineData.loc4.replace(/[()\[\]']/g, ''));
                if (lineData.loc5 && lineData.loc5 !== "#N/A") validLocations.push(lineData.loc5.replace(/[()\[\]']/g, ''));
                if (lineData.loc6 && lineData.loc6 !== "#N/A") validLocations.push(lineData.loc6.replace(/[()\[\]']/g, ''));
                if (lineData.loc7 && lineData.loc7 !== "#N/A") validLocations.push(lineData.loc7.replace(/[()\[\]']/g, ''));
                if (lineData.loc8 && lineData.loc8 !== "#N/A") validLocations.push(lineData.loc8.replace(/[()\[\]']/g, ''));
                if (lineData.loc9 && lineData.loc9 !== "#N/A") validLocations.push(lineData.loc9.replace(/[()\[\]']/g, ''));

                if (validLocations.length > 0) {
                    tooltipText += "With stops in: " + validLocations.join(" → ") + "<br><br>";
                }
    
                    // Generate the image URL
                    const latlong = lineData.lon + "_" + lineData.lat;
                    const imageName = latlong + "_15.png";
                    const imageUrl = "aerial/" + imageName;

                    // Add an image if it exists
                    const image = new Image();
                    image.src = imageUrl;
                    image.onload = function () {
                        d3.select("#tooltip")
                            .select("#val")
                            .html(tooltipText + `<img src='${imageUrl}' width='200' height='200'>`);
                    };
                    image.onerror = function () {
                        // If the image is not found, only show the text
                        d3.select("#tooltip")
                            .select("#val")
                            .html(tooltipText + "Aerial Image not available.");
                    };

                    return tooltipText;
                }

        var cityZoomLevels = {
                'johannesburg': { scale: 1500, center: [28.0473, -20] },// city center [28.0473, -26.2041]
                'nairobi': { scale: 2500, center: [30.8219, 1] }, // city center [36.8219, -1.2921]
                'accra': { scale: 4000, center: [-0.1870, 10] }, // city center [-0.1870, 5.6037]
                'all': { scale: 450, center: [0, 10] } // Default zoom level and center
            };

            function zoomToCity(city) { // Accept selectedCity as a parameter
                    var zoomConfig = cityZoomLevels[city] || cityZoomLevels['all'];
                    // console.log(zoomConfig);
                    // console.log('City Coordinates:', selectedCity, cityCoordinates[selectedCity]);

                    // Update the projection with the new center and scale
                    projection
                        .center(zoomConfig.center)
                        .scale(zoomConfig.scale);

                    // Reapply the projection to the paths (for countries, etc.)
                    svg.selectAll("path")
                        .attr("d", path); // Redraw paths

                    // Recalculate the positions of the lines and text labels with the new projection
                    svg.selectAll(".map-polyline")
                        .attr("x1", d => projection(cityCoordinates[d.city])[0])
                        .attr("y1", d => projection(cityCoordinates[d.city])[1])
                        .attr("x2", d => projection([+d.lat, +d.lon])[0])
                        .attr("y2", d => projection([+d.lat, +d.lon])[1]);

                    svg.selectAll("text")
                        .attr("x", d => projection([+d.lat, +d.lon])[0])
                        .attr("y", d => projection([+d.lat, +d.lon])[1]);
                }

            // document.getElementById('city-select').addEventListener('change', function() {
            //     var selectedCity = this.value;  // Get the selected value
            //     console.log('Selected city:', selectedCity);
            //     // pushData(selectedCity);
            //     // Call a function to filter or handle the city change
            //     // filterDataByCity(selectedCity);
            // }); 

var zoom = d3.zoom()
    .scaleExtent([1, 8])
    .on("zoom", zoomed);

svg.call(zoom);

function zoomed(event) {
    var { transform } = event;

    // Apply the zoom transformation to paths, polylines, text, and highlighted lines
    svg.selectAll("path")
        .attr("transform", transform);

    svg.selectAll(".map-polyline")
        .attr("transform", transform);

    svg.selectAll("text")
        .attr("transform", transform);

    svg.selectAll(".highlight-line")
        .attr("transform", transform);
}

        var chartWidth = 300;
        var chartHeight = 300;
        var padding = 10;

        var categoryColors = {
            "City": cityColor,
            "Town": townColor,
            "Village": villageColor
        };

        var rowConverter = function (d) {
            return {
                resp_id: d.ID,
                city: d.location_l,
                nearcity: d.location_near,
                country_location: d.location_country,
                country_orig: d.orig_country_103,
                num_moves: d.number_moves_200,
                cumulative_dist: parseFloat(d.dist),
                current_city: d.city_8,
                neighborhood: d.neighborhood_9,
                ur_acms: d.Q100_1_URACMS,
                ur_un: d.Q100_1_URUN, 
                lat: d.lat,
                lon: d.lon
            };
        };

        var radialScale = d3.scaleLog()
            .domain([.002, 10000])
            .range([0, chartWidth / 2 - padding]);

        var ticks_set = [.01, 10, 100, 1000, 10000];

        function angleToCoordinate(angle, value) {
            var x = Math.cos(angle) * radialScale(value);
            var y = Math.sin(angle) * radialScale(value);
            return { "x": x, "y": y }; // Remove offset to center in the group
        }

        function polarCoords(value, index, list) {
            var angle = Math.PI / 2 + ((index * 2 * Math.PI) / (list.length));
            return angleToCoordinate(angle, value);
        }

        var chartContainer = d3.select("#chart-container");
        var legendContainer = d3.select("#legend-container");

        function updateChart(selectedCity, selectedNeighborhood) {
            chartContainer.selectAll("*").remove();
            legendContainer.selectAll("*").remove();
            d3.select("#chart-title-container").selectAll("*").remove(); // Clear existing title container
            d3.select("#chart-subtext-container").selectAll("*").remove(); // Clear existing subtext container

            var filteredData = dataset.filter(d => (selectedCity === "all" || d.current_city.toLowerCase() === selectedCity) &&
                (selectedNeighborhood === "all" || d.neighborhood.toLowerCase() === selectedNeighborhood));

            // Filter out data points with NaN cumulative_dist
            filteredData = filteredData.filter(d => !isNaN(d.cumulative_dist));

            // Sort data first by ur_acms (category/color) and then by cumulative_dist
            filteredData.sort((a, b) => {
                if (categoryColors[a.ur_acms] < categoryColors[b.ur_acms]) return -1;
                if (categoryColors[a.ur_acms] > categoryColors[b.ur_acms]) return 1;
                return b.cumulative_dist - a.cumulative_dist;
            });

            var svg = chartContainer.append("svg")
                .attr("width", 400)
                .attr("height", 400);

            var circle_group = svg.append("g")
                .attr("class", "chart")
                .attr("transform", "translate(" + chartWidth / 2 + "," + chartHeight / 2 + ")"); // Center the group

            var lines = circle_group.append("g")
                .attr("class", "lines");

            lines.selectAll("line")
                .data(filteredData)
                .enter()
                .append("line")
                .attr("x1", 0)
                .attr("x2", (d, i, n) => polarCoords(d.cumulative_dist, i, n).x)
                .attr("y1", 0)
                .attr("y2", function(d, i, n) {
                    var coordinate = polarCoords(d.cumulative_dist, i, n).y;
                    return coordinate;
                })
                .attr("stroke", d => categoryColors[d.ur_acms])
                .attr("stroke-width", 0.5)
                .attr("class", "star-line")
                .on("mouseover", function(event, d) {
                    // Reduce opacity of all lines except the hovered one in the star chart
                    d3.selectAll(".star-line").style("opacity", 0.1);
                    d3.select(this).style("opacity", 1).attr("stroke-width", 2);

                    d3.select("#tooltip")
                        .select("#val")
                        .text("Respondent Classified " + d.ur_acms + ", " + d.location + " with " + d.num_moves + " migrations to " + d.current_city);
                    
                    d3.select("#tooltip").classed("hidden", false);

                    // Highlight the corresponding line on the map
                    var startPoint = projection(cityCoordinates[d.current_city]);
                    var endPoint = projection([+d.lat, +d.lon]);
                    var mapSVG = d3.select("#map svg");

                    mapSVG.append("line")
                        .attr("x1", startPoint[0])
                        .attr("y1", startPoint[1])
                        .attr("x2", endPoint[0])
                        .attr("y2", endPoint[1])
                        .attr("stroke", categoryColors[d.ur_acms])
                        .attr("stroke-width", 2)
                        .attr("class", "highlight-line");

                    d3.selectAll(".map-polyline").style("opacity", 0.05);
                })
                .on("mouseout", function() {
                    // Reset opacity and stroke width of all lines in the star chart
                    d3.selectAll(".star-line").style("opacity", 0.7).attr("stroke-width", 0.5);

                    // Remove the highlighted line from the map
                    d3.select("#map svg .highlight-line").remove();                    
                    d3.selectAll(".map-polyline").style("opacity", 1);

                    // Hide the tooltip
                    d3.select("#tooltip").classed("hidden", true);
                });

            var scale = circle_group.append("g")
                .attr("class", "scale");
            scale.selectAll("circle")
                .data(ticks_set)
                .enter()
                .append("circle")
                .attr("class", "scale")
                .attr("id", (d, i) => "fixed-dist" + i)
                .attr("cx", 0)
                .attr("cy", 0)
                .attr("fill", "none")
                .attr("r", d => radialScale(d))
                .attr("stroke-width", .25);

            scale.selectAll("text")
                .data(ticks_set)
                .enter()
                .append("text")
                .attr("x", 0)
                .attr("y", d => -radialScale(d))
                .text(d => d + " km")
                .attr("class", "scale-path")
                .attr("text-anchor", "middle"); // Center the text

            var scale_relative = circle_group.append("g")
                .attr("class", "scale_rel");

            var dist_markers = distanceMarkers[selectedCity.charAt(0).toUpperCase() + selectedCity.slice(1)] || [];

            scale_relative.selectAll("circle")
                .data(dist_markers)
                .enter()
                .append("circle")
                .attr("class", "scale-dashed")
                .attr("id", (d, i) => "cities-dist" + d.dist)
                .attr("cx", 0)
                .attr("cy", 0)
                .attr("fill", "none")
                .attr("r", function (d) {
                    return radialScale(d.dist);
                })
                .attr("stroke-width", .5);

            scale_relative.selectAll("text")
                .data(dist_markers)
                .enter()
                .append("text")
                .attr("x", d => -radialScale(d.dist))
                .attr("y", d => chartHeight /2 - radialScale(d.dist))
                .text(d => d.name + ", " + d.dist + " km")
                .attr("class", "scale-path")
                .attr("text-anchor", "left");

            // City-specific examples for each category
            var cityExamples = {
                'accra': {
                    'City': ["Madina, Ghana", "Bamako, Mali"],
                    'Town': ["Gushiegu, Ghana", "Enugu, Nigeria"],
                    'Village': ["Yendi, Ghana", "Sokode, Togo"]
                },
                'nairobi': {
                    'City': ["Mwanza, Tanzania", "Khartoum, Sudan"],
                    'Town': ["Wote, Kenya", "Garissa, Kenya"],
                    'Village': ["Siaya, Kenya", "Minembwe, D.R.C."]
                },
                'johannesburg': {
                    'City': ["Mwanza, Tanzania", "Khartoum, Sudan"],
                    'Town': ["Wote, Kenya", "Garissa, Kenya"],
                    'Village': ["Kranskop, South Africa", "Mzimba, Malawi"]
                }
            };

            var examples = cityExamples[selectedCity] || cityExamples[''];

            // Update legends
            updateLeftLegend(filteredData);
            updateRightLegend(examples, filteredData, selectedCity);

            if (selectedCity !== 'all') {

                let descripTitle;
                    if (selectedNeighborhood === "all") {
                        descripTitle = `Migrations to ${capitalizeFirstLetter(selectedCity)}`;
                    } else {
                        descripTitle = `Migrations to ${capitalizeFirstLetter(selectedNeighborhood)}, ${capitalizeFirstLetter(selectedCity)}`;
                    }

                d3.select("#chart-title-container").append("div")
                    .attr("class", "chart-title")
                    .text(descripTitle);

                    let subtextContent;
                    if (selectedNeighborhood === "all") {
                        subtextContent = `Migration paths for all neighborhoods in ${capitalizeFirstLetter(selectedCity)} categorized by Q100 of the ACMS survey.`;
                    } else {
                        subtextContent = `Migration paths for respondents currently living in ${capitalizeFirstLetter(selectedNeighborhood)}, ${capitalizeFirstLetter(selectedCity)} categorized by Q100 of the ACMS survey.`;
                    }

                    d3.select("#chart-subtext-container").append("div")
                        .attr("class", "chart-subtext")
                        .text(subtextContent);

            }
        }

        function updateLeftLegend(filteredData) {

            // console.log(filteredData);
            var leftLegendContainer = d3.select("#left-legend-container");
            leftLegendContainer.selectAll("*").remove();

            var totalResponses = filteredData.length;
            var categoryCounts = d3.rollup(filteredData, v => v.length, d => d.ur_acms);
            var UNCounts = d3.rollup(filteredData, v => v.length, d => d.ur_un);

            var urbanCount = categoryCounts.get('City') || 0;
            var townCount = categoryCounts.get('Town') || 0;
            var villageCount = categoryCounts.get('Village') || 0;
            var unUrbanCount = UNCounts.get('Urban') || 0;
            var unNonUrbanCount = UNCounts.get('Non-Urban') || 0;
            var unclassifiedCount = UNCounts.get('Unclassified') || 0;

            var legendCombinedContainer = leftLegendContainer.append("div")
                .attr("class", "legend-combined-container");

            var legendHeaderContainer = legendCombinedContainer.append("div")
                .attr("class", "legend-header-container");

            legendHeaderContainer.append("div")
                .attr("class", "legend-header")
                .text("U.N. WPP")
                .style("color","#9c9c9c");

            legendHeaderContainer.append("div")
                .attr("class", "legend-subtext")
                .style("text-align", "right")
                .text("> 300k pop / km²");

            var legendTitleContainer = legendCombinedContainer.append("div")
                .attr("class", "legend-title-container");

            legendTitleContainer.append("div")
                .attr("class", "legend-header")
                .text("100: Village, City, or Town");

            var legendSVGContainer = leftLegendContainer.append("div")
                .attr("class", "legend-svg-container");

            var legendSVG = legendSVGContainer.append("svg")
                .attr("width", 300)
                .attr("height", 120);

            var legendGroup = legendSVG.append("g")
                .attr("transform", "translate(10, 40)");

            // Labels for categories
            legendGroup.append("text")
                .attr("x", 50)
                .attr("y", 0)
                .attr("class", "legend-category")
                .attr("text-anchor", "middle")
                .text("people");

            legendGroup.append("text")
                .attr("x", 150)
                .attr("y", 0)
                .attr("class", "legend-category")
                .attr("text-anchor", "middle")
                .text("city");

            legendGroup.append("text")
                .attr("x", 200)
                .attr("y", 0)
                .attr("class", "legend-category")
                .attr("text-anchor", "middle")
                .text("town");

            legendGroup.append("text")
                .attr("x", 250)
                .attr("y", 0)
                .attr("class", "legend-category")
                .attr("text-anchor", "middle")
                .text("village");

            // People count with line
            legendGroup.append("text")
                .attr("x", 50)
                .attr("y", 40)
                .attr("class", "legend-number")
                .attr("text-anchor", "middle")
                .text(totalResponses);

            legendGroup.append("line")
                .attr("x1", 90)
                .attr("y1", 36)
                .attr("x2", 140)
                .attr("y2", 36)
                .attr("stroke", "black")
                .attr("stroke-width", 1);

            legendGroup.append("text")
                .attr("x", 90)
                .attr("y", 40)
                .attr("class", "legend-label")
                .attr("text-anchor", "start")

            // City count
            legendGroup.append("rect")
                .attr("x", 140)
                .attr("y", 20)
                .attr("width", 40)
                .attr("height", 40)
                .attr("fill", cityColor);

            legendGroup.append("text")
                .attr("x", 160)
                .attr("y", 45)
                .attr("class", "legend-number")
                .attr("text-anchor", "middle")
                .text(urbanCount);

            // Line connecting city to town
            legendGroup.append("line")
                .attr("x1", 180)
                .attr("y1", 36)
                .attr("x2", 280)
                .attr("y2", 36)
                .attr("stroke", "black")
                .attr("stroke-width", 1);

            // Line under legend 
            legendGroup.append("line")
                .attr("x1", 25)
                .attr("y1", 72)
                .attr("x2", 280)
                .attr("y2", 72)
                .attr("stroke", "black")
                .attr("stroke-width", 1);

            // Town count
            legendGroup.append("rect")
                .attr("x", 190)
                .attr("y", 20)
                .attr("width", 40)
                .attr("height", 40)
                .attr("fill", townColor);

            legendGroup.append("text")
                .attr("x", 210)
                .attr("y", 45)
                .attr("class", "legend-number")
                .attr("text-anchor", "middle")
                .text(townCount);

            // Line connecting town to village
            legendGroup.append("line")
                .attr("x1", 240)
                .attr("y1", 36)
                .attr("x2", 280)
                .attr("y2", 36)
                .attr("stroke", "black")
                .attr("stroke-width", 1);

            // Village count
            legendGroup.append("rect")
                .attr("x", 240)
                .attr("y", 20)
                .attr("width", 40)
                .attr("height", 40)
                .attr("fill", villageColor);

            legendGroup.append("text")
                .attr("x", 260)
                .attr("y", 45)
                .attr("class", "legend-number")
                .attr("text-anchor", "middle")
                .text(villageCount);

            // Adding other text elements
            var details = [
                { label: 'urban', value: unUrbanCount },
                { label: 'unclassified', value: unclassifiedCount },
                { label: 'non-urban', value: unNonUrbanCount },

            ];

            details.forEach(detail => {
                var detailContainer = leftLegendContainer.append("div")
                    .attr("class", "legend-detail-container");

                detailContainer.append("div")
                    .attr("class", "legend-subtext-2")
                    .text(detail.label);

                detailContainer.append("div")
                    .attr("class", "legend-number")
                    .style("color","#9c9c9c")
                    .text(detail.value);
            });
        }


        function updateRightLegend(examples, filteredData, selectedCity) {
            var rightLegendContainer = d3.select("#right-legend-container");
            rightLegendContainer.selectAll("*").remove();

            var totalResponses = filteredData.length;
            var categoryCounts = d3.rollup(filteredData, v => v.length, d => d.ur_acms);

            var urbanCount = categoryCounts.get('City') || 0;
            var townCount = categoryCounts.get('Town') || 0;
            var villageCount = categoryCounts.get('Village') || 0;
            var unclassifiedCount = totalResponses - urbanCount - townCount - villageCount;

            var urbanPercentage = ((urbanCount / totalResponses) * 100).toFixed(1);
            var townPercentage = ((townCount / totalResponses) * 100).toFixed(1);
            var villagePercentage = ((villageCount / totalResponses) * 100).toFixed(1);

            rightLegendContainer.append("div")
                .attr("class", "legend-title")
                .text("Percentages of migration origins");

            rightLegendContainer.append("div")
                .attr("class", "legend-subtext")
                .text("100: Village, City, or Town");

            var legendData = [
                { category: "City", color: cityColor, percentage: urbanPercentage + "%", examples: examples['City'] },
                { category: "Town", color: townColor, percentage: townPercentage + "%", examples: examples['Town'] },
                { category: "Village", color: villageColor, percentage: villagePercentage + "%", examples: examples['Village'] }
            ];

            legendData.forEach(item => {
                var legendItem = rightLegendContainer.append("div")
                    .attr("class", "legend-item");

                legendItem.append("div")
                    .attr("class", "legend-color")
                    .style("background-color", item.color)
                    .style("width", "18px")
                    .style("height", "18px");

                var textContainer = legendItem.append("div")
                    .attr("class", "legend-text");

                textContainer.append("div")
                    .attr("class", "legend-category")
                    .html(`<span>${item.category}</span>&nbsp;<span class="legend-percentage">${item.percentage}</span>`);


                textContainer.append("div")
                    .attr("class", "legend-subtext")
                    .html(`i.e ${item.examples.join(", ")}`);
            });
        }

        function capitalizeFirstLetter(string) {
            return string.charAt(0).toUpperCase() + string.slice(1);
        }

        var legendDiv = d3.select("#people-legend");

        var svgWidth = 300;  // Set the initial desired width
        var svgHeight = 50; // Set the desired height
        var strokeThicknesses = [1, 2, 3, 4, 3]; // Line thicknesses
        var labels = [1, 3, 5, 7, 10]; // Labels to display below the lines

        var initialLineLength = svgWidth; // Starting length for the first line

        // Create the SVG element inside the div
                var peopleLegend = legendDiv.append("svg")
                    .attr("width", svgWidth)
                    .attr("height", svgHeight);

        var cumulativeY = 0;
        strokeThicknesses.forEach(function(thickness, index) {
            var currentLineLength = initialLineLength - (index * 50); // Decrease line length for each line

            if (currentLineLength < 0) {
                currentLineLength = 0; // Ensure the line length doesn't become negative
            }

            peopleLegend.append("line")
                .attr("x1", svgWidth) // Start from the right side
                .attr("x2", svgWidth - currentLineLength) // Draw to the left
                .attr("y1", cumulativeY)
                .attr("y2", cumulativeY)
                .attr("stroke", "black")
                .attr("stroke-width", thickness*2);

            // Add text label below the line
            peopleLegend.append("text")
                .attr("x", svgWidth - currentLineLength )
                .attr("y", 30)
                .attr("class", "legend-subtext") 
                .text(labels[index]); // Set the text to the corresponding label

            cumulativeY += thickness; // Increase the cumulative y-coordinate by the thickness of the current line

            peopleLegend.append("text")
            .attr("x", svgWidth-40) 
            .attr("y", 30)
            .attr("class", "legend-subtext") 
            .text('people')

        });

        var dataset;

        d3.csv("data/star_origins_UR.csv", rowConverter).then(function (data) {
            dataset = data;

            var cities = Array.from(new Set(data.map(d => d.current_city)));
            cities.unshift("All"); // Capitalize "All"
            var citySelect = d3.select("#city-select");

            citySelect.selectAll("option")
                .data(cities)
                .enter()
                .append("option")
                .text(d => d)
                .attr("value", d => d.toLowerCase());

            citySelect.on("change", function () {
                var selectedCity = d3.select(this).property("value").toLowerCase();

                var neighborhoods = Array.from(new Set(dataset.filter(d => selectedCity === "all" || d.current_city.toLowerCase() === selectedCity).map(d => d.neighborhood)));
                neighborhoods = neighborhoods.filter(n => n !== '-3'); // Exclude "-3" neighborhood
                neighborhoods.unshift("All"); // Capitalize "All"
                var neighborhoodSelect = d3.select("#neighborhood-select");

                neighborhoodSelect.selectAll("option").remove();
                neighborhoodSelect.selectAll("option")
                    .data(neighborhoods)
                    .enter()
                    .append("option")
                    .text(d => d)
                    .attr("value", d => d.toLowerCase());

                neighborhoodSelect.on("change", function () {
                    var selectedNeighborhood = d3.select(this).property("value").toLowerCase();
                    updateChart(selectedCity, selectedNeighborhood);
                    filterPolylines(); // Update the map when the neighborhood is changed
                });

                // Update chart for the first neighborhood
                neighborhoodSelect.property("value", "all").dispatch("change");
            });

            // Initial chart rendering for "all" city and "all" neighborhood
            citySelect.property("value", "all").dispatch("change");
        }).catch(function (error) {
            console.error('Error loading or parsing data:', error);
        });



        function downloadSVG() {

            var mapContainer = document.getElementById('map');
            var svgElement = mapContainer.querySelector("svg"); // Select the SVG element inside the mapContainer

            if (!svgElement) {
                alert("No SVG element found inside the map container.");
                return;
            }

            var width = mapContainer.offsetWidth;
            var height = mapContainer.offsetHeight;

            // Set the viewBox of the SVG element to crop it to the mapContainer dimensions
            svgElement.setAttribute("viewBox", `0 0 ${width} ${height}`);
            svgElement.setAttribute("width", width);
            svgElement.setAttribute("height", height);

            // var svgElement = document.querySelector("#map svg"); // Select the SVG element

            // Create a blob from the SVG XML
            var svgBlob = new Blob([svgElement.outerHTML], { type: "image/svg+xml;charset=utf-8" });
            var svgUrl = URL.createObjectURL(svgBlob);
            var downloadLink = document.createElement("a");
            downloadLink.href = svgUrl;
            downloadLink.download = "map-viz.svg";

            // Trigger the download
            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);
        }

        function downloadLegendPNG() {
            var legendElement = document.querySelector("#legend");
            
            html2canvas(legendElement).then(canvas => {
                var imgData = canvas.toDataURL('image/png');
                var downloadLink = document.createElement("a");
                downloadLink.href = imgData;
                downloadLink.download = "legend.png";

                // Trigger the download
                document.body.appendChild(downloadLink);
                downloadLink.click();
                document.body.removeChild(downloadLink);
            });
        }

    function downloadLegend() {
        var legendElement = document.querySelector("#legend");
        var svgWidth = legendElement.offsetWidth;
        var svgHeight = legendElement.offsetHeight;

        var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg.setAttribute("width", svgWidth);
        svg.setAttribute("height", svgHeight);
        svg.setAttribute("xmlns", "http://www.w3.org/2000/svg");

        appendDivAsSvgElement(svg, document.querySelector("#left-legend-container"), 0, 0);
        appendDivAsSvgElement(svg, document.querySelector("#right-legend-container"), 300, 0);
        appendDivAsSvgElement(svg, document.querySelector("#chart-container"), 600, 0);
        appendDivAsSvgElement(svg, document.querySelector("#chart-title-container"), 600, 200);
        appendDivAsSvgElement(svg, document.querySelector("#chart-subtext-container"), 600, 250);

        var serializer = new XMLSerializer();
        var svgBlob = new Blob([serializer.serializeToString(svg)], { type: "image/svg+xml;charset=utf-8" });
        var svgUrl = URL.createObjectURL(svgBlob);
        var downloadLink = document.createElement("a");
        downloadLink.href = svgUrl;
        downloadLink.download = "legend.svg";

        // Trigger the download
        document.body.appendChild(downloadLink);
        downloadLink.click();
        document.body.removeChild(downloadLink);
    }

    function appendDivAsSvgElement(svg, divElement, offsetX, offsetY) {
        var foreignObject = document.createElementNS("http://www.w3.org/2000/svg", "foreignObject");
        foreignObject.setAttribute("width", divElement.offsetWidth);
        foreignObject.setAttribute("height", divElement.offsetHeight);
        foreignObject.setAttribute("x", offsetX);
        foreignObject.setAttribute("y", offsetY);

        var div = document.createElement("div");
        div.setAttribute("xmlns", "http://www.w3.org/1999/xhtml");
        div.style.width = divElement.offsetWidth + "px";
        div.style.height = divElement.offsetHeight + "px";

        var clonedDiv = divElement.cloneNode(true);
        inlineAllStyles(clonedDiv);
        div.appendChild(clonedDiv);

        foreignObject.appendChild(div);
        svg.appendChild(foreignObject);
    }   

function inlineAllStyles(element) {
    var allElements = element.querySelectorAll("*");
    allElements.forEach(function(el) {
        var computedStyle = getComputedStyle(el);
        var styleString = "";
        for (var key of computedStyle) {
            if (computedStyle.getPropertyValue(key)) {
                styleString += key + ":" + computedStyle.getPropertyValue(key) + ";";
            }
        }
        el.setAttribute("style", styleString);
    });
}

// Example usage: Attach function to a button click
document.getElementById("download-svg").addEventListener("click", downloadSVG);
document.getElementById("download-legend").addEventListener("click", downloadLegend);

</script>
</html>